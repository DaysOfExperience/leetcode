# 类的概念

在C++中，类可以说是最重要的东西，因为C++一开始的定位就是c with class,也正是因为引入了类，才让c++从c的面向过程思想转变为面向对象的思想，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。

## struct

第一种是struct，也就是从C继承而来的，在C语言中，struct可以用来创建结构体，但是结构体中只能保存变量，而不能保存函数，在C++中，struct不仅可以用来创建类，还保留了C语言中结构体的用法

## class

class是C++中定义类的关键字，他的用法和struct类似。

在类中，类的元素被称为类的成员，类中的数据被称为成员变量或者类的属性，类中的函数被称为类的方法或者成员函数

## class与struct的区别

1. C++兼容C语言，所以struct不仅可以定义类，还可以当成结构体使用。

2. 默认访问限定不同，struct的成员默认访问方式为public，class为private
   ，并且struct默认继承方式为public继承，class为private继承

**类的两种定义方式**

1. 声明和定义都在类中

如这种，如果成员函数类中定义，可能会被编译器当为内联函数处理。

```C++
class Date
{
	void PrintDate()
	{
		cout << _year << '-' << _month << '-' << _day << endl;
	}

	int _year;
	int _month;
	int _day;
};
```

2. 声明和定义分离
   这样能让类更加简洁，不那么臃肿，通常都是使用这种方式。

```C++
class Date
{
	void PrintDate();

	int _year;
	int _month;
	int _day;
};

//需要指定这个方法属于Date类
void Date::PrintDate()
{
	cout << _year << '-' << _month << '-' << _day << endl;
}
```

# 类的访问控制和封装

访问限定符有三种，分别是public,private,protected

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020041717222734.png" alt="在这里插入图片描述" style="zoom:67%;" />

1. public修饰的成员在类外可以直接被访问。
2. protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)。
3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。

## C++如何实现封装？

1. 通过class/struct，对对象的属性和方法进行封装
2. 通过访问限定符，将接口暴露给外部，隐藏类的属性和内部实现。

> 在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？
> **封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行**
> **交互。**
> 封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们
> 首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通
> 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。
> 不想给别人看到的，我们使用protected/private把成员封装起来。开放一些公有的成员函数对成员合理的访
> 问。
>
> **所以封装本质是一种管理。**

一般对于对象的属性，我们不希望别人对它进行修改，所以会用private将其封装，但是我们又需要给别人提供获取它的接口，所以会对方法和接口给与public属性

# 类的对象模型

以这个类来探究

```C++
class Date
{
public:
	void PrintDate();

private:
	char a;
	int _year;
	int _month;
	int _day;
};
```

我们可以看到，类中有成员函数，有成员变量，那么类的大小是如何计算的呢？

这里用sizeof查看大小，发现只有成员变量的大小，而没有成员函数的大小
（这里的16是因为内存对齐偏移了3个字节）

## 结构体内存对齐规则

> 1. 第一个成员在与结构体偏移量为0的地址处。
> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
> 3. **注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。**
>    VS中默认的对齐数为8
> 4. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
> 5. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是
>    所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

为什么会只保存了成员变量呢？这里就要引申出类的存储方式

## 类的存储方式

对于上面的类，如果我们将类实例化为多个对象，**实际上这些对象不同的地方只有它的属性，它们调用的方法都是完全相同的，为了不重复保存这些代码，C++只保存了属性，而将方法放到了公共的代码段中，来避免了空间的浪费。**

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200417203813916.png)

## 空类的大小

**同时，如果一个类中什么都没有，编译器会给这个类一个字节，来唯一标识这个类**

**总结：**
**类的大小就是成员变量之和（需要考虑内存对齐）**

## 如何让结构体按照指定的默认对齐数进行对齐？

在C++中，可以使用 `alignas` 关键字来指定结构体的对齐方式。这个关键字用于指示编译器以特定的对齐数对结构体进行对齐。

```C++
struct alignas(4) MyStruct {
    // 结构体成员
};
```

在这个示例中，`MyStruct` 结构体将按照4字节对齐。

# 内存对齐

```C++
struct
{
	char i;
	char k; 
	int j;
}s1;

struct
{
	char i;
	int j;
	char k;
}s2;
	
int main()
{
	printf("%d\n", sizeof(s1));
	printf("%d\n", sizeof(s2));
	return 0;
}
```

> 上面的两个结构体，看上去是完全一样的，只有声明变量时的顺序不一样， 那么它们的大小一样吗？
>
> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20191121204327236.png)
>
> 运行后我们发现，它们两个的大小竟然不同，而且如果我们将它们每一个的大小相加起来，得到的也应该是6，不是上面的两个值，那么这是因为什么呢?
> 这时，就牵扯到了一个叫做内存对齐的东西。

1. 第一个成员在与结构体变量偏移量为0的地址处。
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
   对齐数 = 编译器默认的一个对齐数与该成员大小的较小值（vs的默认值为8，linux默认值为4（32位系统下由于数据总线只有32位，每次只能读取4个字节））

3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到在自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍

> 示例：struct { char i; int j; char k; }s2;
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20191121220401974.png" alt="在这里插入图片描述" style="zoom:67%;" />
>
> 因为第一个i与第二个j是相同类型，所以不存在偏移，k所占据的字节数比j大，所以偏移量为默认对齐数和K的大小的最小值，所以需要偏移到四个字节，所以总共占了八个字节的大小
>
> struct { char i; int j; char k; }s2;
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2019112122114268.png" alt="在这里插入图片描述" style="zoom:67%;" />


看完上面的几个图解，**我们了解到如果要合理运用空间，就应该把占用空间较小的成员尽量集中到一起。**

## 为什么要有内存对齐呢？

在我们能百度到的大部分资料上，都是这样说的:

1. 平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的，**某些硬件平台只能在某些地址处取某些特定类型的数据**，否则抛出硬件异常。
2. 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。**原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅仅需要一次。**（为对齐需要读取多个总线周期）

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20191121223758254.png)

对于没对齐过的，我们如果想读取这个k，因为我们每次读取四个字节，所以第一次读取的时候只读取到了k的前三个字节，第二次才能读取到k的第四个字节，然后将其进行重组，才能得到这个k。如果是对齐过的，我们就可以一次性读取，虽然使用的空间变多了，但是速度也快了很多。

**所以内存对齐的意义就是用空间来换取时间，而空间的价格较为低廉，所以内存对齐的性价比是十分高的。**

## 对齐数的修改

当然，系统默认的对齐数是不能适用于所有情况下的，所以我们可以修改对齐数来适用于我们所处的情景。

### C

我们可以使用一个预处理指令来修改默认的对齐数 # pragma pack(x)， 这个x就填入我们想修改的数值

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20191121224927164.png" alt="在这里插入图片描述" style="zoom:67%;" />

如果我们想要只在一段使用这个对齐数，而在下一段恢复的话，可以这样使用

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20191121225033714.png" alt="在这里插入图片描述" style="zoom:67%;" />

### C++

可以使用 `alignas` 关键字来指定结构体的对齐方式。这个关键字用于指示编译器以特定的对齐数对结构体进行对齐。

```C++
struct alignas(4) MyStruct {
    // 结构体成员
};
```

在这个示例中，`MyStruct` 结构体将按照4字节对齐。