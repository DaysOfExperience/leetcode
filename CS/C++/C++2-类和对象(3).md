# explicit关键字

```C++
class Date
{
public:
	Date(int year = 0, int month = 4, int day = 24)
		:_year(year),
		 _month(month),
		 _day(day)
	{}

	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2020, 4, 24);
	
	Date d2 = 2020;//C++98
	Date d3 = { 2020, 4 }; //C++11
	Date d4 = { 2020, 4, 24 }; //C+11
}
```

对于这里的d2,我们用2020给它赋值，而d3和d4分别用了列表来给它赋值，并且这四个对象它们最后的值是一模一样的，那是为什么呢？这里的2020明明是一个整型，d3和d4是一个列表，为什么能够给对象赋值呢？

这里就牵扯到了隐式的类型转换

**这里其实是先用这个整型值来调用了全缺省的构造函数来创建了一个临时对象，再使用这个对象来为d2,d3,d4赋值。**

这是一种很容易引起误会的写法，**所以c++提供了关键字explicit，用这个关键字修饰的函数就会禁止隐式类型的转化**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200424202910400.png" alt="在这里插入图片描述" style="zoom:67%;" />


这时这种隐式类型转换就不会发生了

# 匿名对象

当我们想要调用对象中的一个方法，或者只是想在这一句使用这个对象，其他地方不再使用对象的时候，如果我们直接构造一个对象使用，这无疑是一种很大的浪费，因为这个对象我们用了一次就扔了，不再需要了，而一个对象的生命周期是整个栈帧。

**这时就需要用到匿名对象，匿名对象是一种临时的对象，它的生命周期只有使用它的那一行语句，执行完则立即销毁**

```C++
class Date
{
public:
	Date(int year = 2020, int month = 4, int day = 24)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print(int year)
	{
		cout << "this year is " << year << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1;
	d1.Print(2020);
	//创建一个对象，生命周期为整个函数栈帧

	Date().Print(2020);
	//创建一个匿名对象，生命周期只有这一行语句，实行完则立即调用析构函数
}
```


所以当我们只想在这一行使用对象时，就可以考虑使用匿名对象。

# 友元

## 友元函数

其实上一章我重载的运算符还存在一个问题，就是访问权限的问题
Date类的所有成员变量都是private的，这里是无法访问的，只有将函数声明为友元函数，才能使用

```C++
bool operator==(const Date& d1, const Date& d2)
{
	return d1._year == d2._year
		&& d1._month == d2._month
		&& d1._day == d2._day;
}
```

友元函数可以访问类中的所有成员，包括private,和protect，所以只需要将这个函数声明为类的友元函数即可。

**友元函数需要在类内进行声明，声明时用friend关键字来修饰。**

> 友元函数可访问类的私有和保护成员，但不是类的成员函数
> 友元函数不能用const修饰
> 友元函数可以在类定义的任何地方声明，不受类访问限定符限制
> 一个函数可以是多个类的友元函数
> 友元函数的调用与普通函数的调用和原理相同

## 友元类

如果我们想在一个类中，访问另一个类的私有成员，可以做到吗?
答案是可以的，friend也可以用来修饰类，也就是友元类。

```C++
class A
{
	friend class Date;
	//将Date声明为友元类，Date可以访问A的所有成员变量
private:
	string str;
};
class Date
{
public:
	void Print()
	{
		cout << a.str << endl;
		//访问a的私有成员
	}
private:
	int _year;
	int _month;
	int _day;
	A a;
};
```

只需要在要被访问的类中，使用friend class来声明对应的类为友元类，那个类就可以访问了。

注意

1. 友元关系是单向的，不具有交换性。
   Date为A的友元，可以访问A的私有成员，但是A并不能访问Date的

2. 友元关系不能传递
   如果B是A的友元，C是B的友元，则不能说明C时A的友元。

# 内部类

有没有想过，既然类的成员变量可以是自定义类型，那能不能在类中再构建一个类呢？

```C++
class Date
{
public:
	void Print()
	{
		cout << _year << endl;
	}
private:
	class A
	{
	public:
		void Print()
		{
			cout << _data << endl;
		}
	private:
		int _data;
	};
	int _year;
	int _month;
	int _day;
};
```

可以看到，这是可以的，但是这两个类有什么关系吗？

这个内部类其实是一个独立的类，它不属于外部类，同时外部类对它也没有任何特权，但是**它同时还是外部类的友元类，可以通过外部类的对象参数来访问外部类的所有成员。**

特性：
1. 内部类可以定义在外部类的public、protected、private都是可以的。
2. 注意内部类可以直接访问外部类中的static、枚举成员、不需要外部类的对象/类名。
3. sizeof(外部类)=外部类，和内部类没有任何关系。

# 类的static成员

对于用static修饰的成员函数，称为静态成员函数，成员变量称为静态成员变量。

**如果对于一个成员，对其以static修饰，此时这个成员就不再属于对象，而是属于这一整个类的所有对象。**

**因为静态的成员的生命域不在类中，在静态区，所以静态的成员只能在类外初始化。**

> 1. 静态成员为所有类对象所共享，不属于某个具体的实例，因此也不影响sizeof的结果
> 2. **静态成员变量必须在类外定义，定义时不添加static关键字**
> 3. 类静态成员即可用类名::静态成员或者对象.静态成员来访问
> 4. 静态成员函数没有隐藏的this指针，不能访问任何非静态成员
> 5. 静态成员和类的普通成员一样，也有public、protected、private3种访问别
> 6. 静态成员和全局变量虽然都存储在静态区，但是静态成员的生命周期只在本文件中，而全局变量不是
> 7. 静态成员函数不能设置为虚函数

因为静态成员函数不属于某个对象，所以它没有this指针，无法访问任何非静态的成员，但是非静态的成员函数具有this指针，可以访问静态的成员。

# 类的const成员

因为对于类和对象，封装性是一个很重要的东西，但是访问限定符只对外部有影响，对自身的成员函数没有影响

## const成员函数

如果我们不想让一个成员函数对类的成员进行修改，这时，就需要用const来修饰成员函数。

```C++
class Date
{
public:
	//等价于 void print(const Date* this)
	void Print() const
	{
		cout << _year << '-' << _month << '-' << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
	
};
```

对于用const修饰的成员函数，需要将const放在最后面，来区分开const参数和const返回值。**这里的const其实修饰的是该成员函数的this指针，所以该成员函数就无法对类的成员进行修改。**（this指针添加了底层属性~）

const对象可以调用非const成员函数吗？
答案：不行，因为const对象的只能读不能写，而非const的成员函数则可读可写，使权限放大了，不行。

非const对象可以调用const成员函数吗？
答案：可以，因为非const对象的可读可写，const成员函数只可读，使权限缩小，可行。

const成员函数内可以调用其它的非const成员函数吗？
答案：不行，因为const成员函数的this指针具有底层const属性不能写对象，而非const的成员函数则可读可写，使权限放大了，不行。

非const成员函数内可以调用其它的const成员函数吗？
答案：可以，因为非const成员函数的this指针可读可写，const成员函数只可读，使权限缩小，可行。

## const数据成员

1. 该成员变量不能在成员函数中被修改
2. 必须在构造函数的列表初始化中进行初始化

# static

1. **在函数内部的静态变量：** 
   当 `static` 用于函数内部的变量时，它会使变量的作用域限制在声明它的函数内部，但它的生存周期会持续整个程序的执行过程，即该变量在函数调用之间保持其值。每次函数调用时，该变量的值都会被保留。
2. **在文件内部的静态全局变量：**
   当 `static` 用于文件（编译单元）内部的全局变量时，**它将限制该变量的作用域仅在当前文件内部**，其他文件无法访问该变量。这在一定程度上实现了信息的封装。

# extern

1. **声明全局变量：** 
   当你在一个文件中定义了一个全局变量，并且希望在其他文件中使用它，你可以在其他文件中使用 `extern` 关键字来声明该全局变量，以便编译器知道该变量在其他地方有定义。

```C++
// File1.c
int globalVar = 42;
```

```C++
// File2.c
extern int globalVar; // 声明全局变量，让编译器知道在其他文件中有定义
```

2. **声明全局函数：**
   类似于全局变量，你可以使用 `extern` 来声明在其他文件中定义的全局函数，以便在当前文件中调用这些函数。

```C++
// File1.c
void someFunction() {
    // ...
}
```

```C++
// File2.c
extern void someFunction(); // 声明全局函数，使其可在当前文件中调用
```

# static+extern

在一个文件中定义了 `static` 全局变量，这个变量的作用域仅限于当前文件，其他文件无法访问这个变量。而另一个文件如果使用 `extern` 来引用这个 `static` 全局变量是不会发生冲突的，因为 `static` 全局变量的作用域局限于其定义所在的文件。

具体来说：

- 在文件 A 中定义了一个 `static` 全局变量：

  ```
  // FileA.c
  static int staticGlobalVar = 42;
  ```

- 在文件 B 中使用 `extern` 引用这个 `static` 全局变量（这种用法在 C 语言中可能会被编译器警告，因为 `static` 变量的作用域不应该跨越文件）：

  ```
  // FileB.c
  extern int staticGlobalVar;  // 不会与 FileA.c 中的 staticGlobalVar 冲突
  ```

在这个例子中，虽然在文件 B 中使用了 `extern` 来引用 `static` 全局变量，**但由于 `staticGlobalVar` 是一个静态全局变量，它的作用域仅限于文件 A**，所以在文件 B 中无法直接访问该变量。这种情况下不会产生冲突，但也不会实现变量的共享。

需要注意的是，尽管可以通过 `extern` 来引用 `static` 全局变量，但这样做可能会造成混淆和代码可读性问题。如果你想要在不同文件之间共享变量，更常见的做法是将变量声明为普通的全局变量，而不是 `static`。

**编译文件 B 时，如果你尝试使用 `extern` 来引用文件 A 中的 `static` 全局变量，不会直接报错，但会在链接阶段出现错误。从而产生链接错误。**