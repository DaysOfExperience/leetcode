# 一、多态的定义和实现

### 多态的构成条件：

构成多态需要两个条件：

1. **必须通过基类的指针或者引用调用虚函数**

2. **被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写（不是隐藏）**

> 虚函数：被virtual修饰的类成员函数称为虚函数。注意，这里和虚继承的virtual只是名字一样，但是作用完全不同

### 虚函数的重写（覆盖）：

**派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了父类的虚函数。** （只重写了函数实现。）

### 多态的两个特殊点：

1. 派生类中对基类虚函数进行重写时，可以省略virtual关键字，此时该函数仍然为虚函数且构成重写。不过还是建议加上virtual声明，更规范。（因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性）

2. 协变：派生类对基类虚函数进行重写时，要求函数名，参数列表，返回值都相同。一个例外是返回值类型可以不同，基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变。此时也会构成重写。

### 析构函数的重写：

回顾继承：

1. 在继承体系中，派生类的析构函数会自动调用基类析构函数去清理基类部分数据成员（先派生，后基类）

2. 并且编译器会将继承体系中的析构函数函数名处理为destructor，**所以若不将基类析构函数定义为虚函数，默认为隐藏关系！**

那么，如果执行下面代码时，析构函数就必须重写！

```cpp
class Base
{
public:
	Base()
		:p(new int[10])
	{
	}
	virtual ~Base()
	{
		cout << "~Base()" << endl;
		delete p;
	}
protected:
	int* p;
};

class Derived : public Base
{
public:
	Derived()  // 自动调用基类的默认构造函数
		:p2(new double[10])
	{
	}
	virtual ~Derived()
	{
		cout << "~Derived()" << endl;
		delete p2;
	}
protected:
	double* p2;
};

int main()
{
	Base* p = new Base;
	delete p;
	Base* p2 = new Derived;
	delete p2;
	return 0;
}
```

delete p2时，delete语句会执行p2->destructor();  operator delete(ptr2); **调用p2所指向的析构函数**，**此时若不将析构函数定义为虚函数，则不会发生重写，而是隐藏。则第二个delete时，事实上，Derived类中会有两个析构函数，一个是基类的，一个是自己的。p2类型为Base*，且没有发生多态，只能调用基类的析构函数。**

**因此，诸如上方示例，建议将继承体系中的析构函数定义为虚函数，这样子类就可以对父类析构函数进行重写。**

可以理解，编译后析构函数函数名被编译器处理为destructor()，也是为了便于设为虚函数，发生多态和动态绑定。**这样delete基类指针时，才能调用正确的析构函数，即指向父类调用父类的析构函数，指向子类调用子类的析构函数。**

---

> 简单来说：继承体系中的析构函数，如果基类不设置为virtual虚函数，则派生类和基类的析构函数为隐藏关系。
>
> 而如果将基类析构函数定义为virtual，则构成重写（覆盖）的关系
>
> 只有在重写时，基类指针指向派生类对象时，delete基类指针才能发生多态，也就是调用派生类的析构函数。

### override和final

1. final：修饰虚函数，表示该虚函数不能再被重写

2. override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。

### 重载，重定义（隐藏），重写（覆盖）的区别

> 重载：两个函数在同一定义域，函数名相同，参数的类型/顺序/个数不同
>
> 重定义（隐藏）：两个函数分别在基类和派生类的作用域中，函数名相同。
>
> 重写（覆盖）：两个函数分别在基类和派生类的作用域中，基类函数为virtual，函数名，参数，返回值相同（协变除外）
>
> 事实上，基类和派生类中，两个函数如果函数名相同，若没有构成重写，就是重定义（隐藏）

# 二、抽象类

### 2.1 纯虚函数

**在虚函数的后面写上 =0 ，则这个函数为纯虚函数。**包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。派生类继承后也不能实例化出对象（因为继承了纯虚函数），只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。

```cpp
class Base
{
public:
    virtual void Drive() = 0;
};
```

### 2.2 接口继承和实现继承

**普通函数的继承是一种实现继承**，派生类继承了基类函数，可以使用函数，继承的是函数的实现

**虚函数的继承是一种接口继承**，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。

# 三、多态的原理 - 虚函数表

## 虚函数表

```cpp
class Base
{
public:
	Base()
		:p(new int[10])
	{
	}
	virtual ~Base()
	{
		delete p;
	}
	virtual void Func1()
	{
		cout << "virtual void Base::Func1()" << endl;
	}
	virtual void Func2()
	{
		cout << "virtual void Base::Func2()" << endl;
	}
    void Func3()
    {
        cout << "void Base::func3()" << endl;
    }
protected:
	int* p;
};

class Derived : public Base
{
public:
	Derived()  // 自动调用基类的默认构造函数
		:p2(new double[10])
	{
	}
	virtual ~Derived()
	{
		delete p2;
	}
	virtual void Func1() // 重写基类Func1
	{
		cout << "virtual void Derived::Func1()" << endl;
	}
protected:
	double* p2;
};

void test1()
{
	Base b;
	Derived d;
}
```

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/09904e0a470e45c29f5d5eb459996697.png)!

1. **每一个含有虚函数的类的实例化对象中都有一个指针成员，称为虚函数表指针（虚表指针）**，即上图中的_vfptr(virtual function ptr)，这个指针指向一个虚函数表（简称虚表，一个函数指针数组），**这个虚函数表中会存储这个类定义的所有虚函数的地址。**

2. 因为基类定义了虚函数，所以每一个虚函数的地址会存储在基类的虚表指针指向的虚表中，派生类继承基类，这个虚表指针作为基类的数据成员也被继承了下来，**派生类内重写了的虚函数的地址会覆盖基类的虚函数的地址。**故上图中，基类和派生类的虚表中析构函数的地址不同，Func1的地址不同，而Func2的地址相同。

3. **虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数地址的覆盖。重写是语法的叫法，覆盖是原理层的叫法。**（派生类虚表中Func1和析构函数覆盖基类的Func1和析构函数）

4. 基类的非虚函数Func3不会放进虚表中。

5. 容易混淆的问题：虚函数存在哪的？虚表存在哪的？ 虚函数和普通函数一样，存储在代码段。类对象中存储的是虚表指针，而不是虚表。虚表中存储的是虚函数的地址，而不是虚函数。**虚表事实上也是存储在代码段的**（只读的，vs下）**所以得出结论，虚函数表在编译阶段生成，存储于代码段。**

6. 派生类虚表生成大致过程：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

验证派生类自己新增的虚函数会不会存储在派生类虚表中：

```cpp
class Base
{
public:
	Base()
		:p(new int[10])
	{
	}
	//virtual ~Base()
	//{
	//	delete p;
	//}
	virtual void Func1()
	{
		cout << "virtual void Base::Func1()" << endl;
	}
	virtual void Func2()
	{
		cout << "virtual void Base::Func2()" << endl;
	}
protected:
	int* p;
};

class Derived : public Base
{
public:
	Derived()  // 自动调用基类的默认构造函数
		:p2(new double[10])
	{
	}
	//~Derived()
	//{
	//	delete p2;
	//}
	virtual void Func1() // 重写基类Func1
	{
		cout << "virtual void Derived::Func1()" << endl;
	}
	virtual void new_add()
	{
		cout << "virtual void Derived::new_add()" << endl;
	}
protected:
	double* p2;
};

typedef void(*VFPtr)();

void print_virtual_function_table(VFPtr* VFTable)  // 函数指针数组
{
	for (int i = 0; VFTable[i]; ++i)
	{
		printf("VFTable[%d] : %p\n", i, VFTable[i]);
		VFTable[i]();
	}
}
void test1()
{
	Base b;
	Derived d;
	print_virtual_function_table((VFPtr*)*(int*)&d);
}
```

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/3e805675018a436687a5200dc2b45a23.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/f33652234f134324bfe3bfcd7d1bb712.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

事实证明，派生类自己新增的虚函数是会按照声明顺序添加到自己的虚函数表的后端的。只是VS下的监控窗口隐藏了。 

## 多态的原理

有了上面虚函数表和虚函数指针的基础，再来理解多态的原理。

![img](https://img-blog.csdnimg.cn/87dd926242b44f70a17d7e644f08aae0.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

如上，符合多态的条件：基类指针调用重写好的虚函数。

1. 多态调用：程序（进程）运行过程中，会去指针指向的对象的虚表指针指向的虚表中找到函数的地址，进行调用。所以，p2指向的是基类，调用基类的虚函数，指向派生类，调用派生类的虚函数。

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/b31f2bd6a8094baba124fe662a88df52.png)

2. 不满足多态的普通函数调用，编译链接时已经确定函数的地址，运行时直接调用。

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/cd554fc9bc294038b8034b668b167fe8.png)

## 动态绑定与静态绑定

对象的静态类型：对象在声明时采用的类型。是在编译期确定的。

对象的动态类型：指针或引用所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改

**静态绑定**又称为**前期绑定(早绑定)**，在**程序编译期间**确定了程序的行为，也称为静态多态， 比如：函数重载（重载也是一种多态的表现，只不过重载是在编译的时候确定程序的行为，所以也被**静态多态**。）

**动态绑定**又称**后期绑定(晚绑定)**，是在**程序运行期间**，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。

## 常见问题解析

**内联函数可以是虚函数吗？**
不可以，内联函数没有地址，无法放进虚函数表中。

**静态成员函数可以是虚函数吗？**
不可以，静态成员函数没有this指针，无法访问虚函数表。

**构造函数可以是虚函数吗？**
不可以，虚函数表指针也是对象的成员之一，是在构造函数初始化列表初始化时才生成的，不可能是虚函数

**析构函数可以是虚函数吗？**
可以，上面有写，最好把基类析构函数声明为虚函数，防止使用基类指针或者引用指向派生类对象时，派生类的析构函数没有调用，可能导致内存泄漏。

**对象访问虚函数快还是普通函数快？**
**如果不构成多态的话，虚函数和普通函数的访问是一样快的，但是如果构成多态，调用虚函数就得到虚函数表中查找，就会导致速度变慢，所以普通函数更快一些。**

# 四、多继承中的虚函数表

### 4.1 普通多继承下的虚函数表：

```cpp
class Base1
{
public:
	virtual void func1() {
		printf("Base1::func\n");
	}
	virtual void func2() {
		cout << "Base1::func2" << endl;
	}
private:
	int b1;
};

class Base2 {
public:
	virtual void func1() { cout << "Base2::func1" << endl; }
	virtual void func2() { cout << "Base2::func2" << endl; }
private: 
	int b2;
};

class Derive : public Base1, public Base2 {
public:
	virtual void func1() { cout << "Derive::func1" << endl; }
	virtual void func3() { cout << "Derive::func3" << endl; }
private:
	int d1;
};

typedef void(*VFPtr)();

void print_virtual_function_table(VFPtr* VFTable)  // 函数指针数组
{
	for (int i = 0; VFTable[i]; ++i)
	{
		printf("VFTable[%d] : %p\n", i, VFTable[i]);
		VFTable[i]();
	}
}

int main()
{
	Base1 b;
	Derive d;
	print_virtual_function_table((VFPtr*)*(int*)&d);
	cout << endl;
	print_virtual_function_table((VFPtr*)*(int*)((char*)&d + sizeof(Base1)));
	return 0;
}
```

派生类有两个基类，每个基类都有定义虚函数，则每个基类都有虚函数表指针，**派生类继承就会有两个虚函数表指针**，func1进行了重写，因此两个虚表中func1的地址都进行了覆盖。func2没有覆盖。而派生类自己新增的虚函数会存储在第一个继承的基类部分的虚函数表中
![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/a39f2e1e5e90437ab228d3b9f7c663b9.png)

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/26b01cbbfb00419eb944a3cb9bf27c60.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

> 注：这里存在很多编译器的行为，比如这里的地址事实上并不是函数的真实地址（函数的第一条指令的地址），而是某跳转指令的地址，跳转指令会跳转至函数真正的执行语句。但是我们依然理解为虚表中存储的是虚函数的地址！

> 第二个点：上图中打印的派生类重写了的func1函数，函数地址不同，这里是因为Base2* 去调用这个func1时，要进行一些额外操作：Base2\*指向的是基类Base2部分的虚表指针处，调用func1需要事先将此指针减一些偏移量，使其指向派生类对象的开端，即派生类对象的地址，因此函数地址不同。下图所示，执行eax - 8
>
> 下图为派生类对象直接调用func1和Base1\*调用func1（指向派生类），Base2*调用func1（指向派生类）的汇编代码。![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/8aadad5bdde642a9bb09aca9d7b4c98d.png)

### 4.2 菱形继承下的多态

```cpp
class A
{
public:
	virtual void func1()
	{
		cout << "A::func1()" << endl;
	}
public:
	int _a;
};

 //class B : public A
class B : virtual public A
{
public:
	virtual void func1()
	{
		cout << "B::func1()" << endl;
	}

	virtual void func2()
	{
		cout << "B::func2()" << endl;
	}
public:
	int _b;
};

 //class C : public A
class C : virtual public A
{
public:
	virtual void func1()
	{
		cout << "C::func1()" << endl;
	}

	virtual void func2()
	{
		cout << "C::func2()" << endl;
	}
public:
	int _c;
};

class D : public B, public C
{
public:
	virtual void func1()
	{
		cout << "D::func1()" << endl;
	}
public:
	int _d;
};

int main()
{
	D d;
	cout << sizeof(d) << endl;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
	//print_virtual_function_table((VFPtr*)*(int*)&d);
	//cout << endl;
	//print_virtual_function_table((VFPtr*)*(int*)((char*)&d + sizeof(B)));
	return 0;
}
```

![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/428372ff17c747d98fcf274637d313f6.png)

 ![img](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/feb9444b6d174504a4c60ee7da5250f0.png)

D中有BC基类数据，还有\_d，BC内都是除了自己的\_b \_c 还有虚表指针（因为虚函数），虚基表指针（因为虚拟继承）。虚基表中存储着到本类的虚表指针的偏移量，以及基类A部分数据的偏移量。基类A中有一个虚表指针（图中的0x00349b90)和自己的_a

# 五、多态题

```cpp
class A
{
public:
   virtual void func(int val = 1){ std::cout<<"A->"<< val <<std::endl;}
   virtual void test(){ func();}
};

class B : public A
{
public:
   void func(int val=0){ std::cout<<"B->"<< val <<std::endl; }
};

int main(int argc ,char* argv[])
{
   B*p = new B;
   p->test();
   return 0;
}
```

前言：关于多态：只需要记住：基类指针或引用调用父类重写好的虚函数时，才会发生多态。
其余的不管是父类没有重写，还是说父类指针去调用，都不构成多态！那么，具体其他情况下的具体调用行为，和编译器具体实现有关，不需要深究。

这里p->test是父类指针调用，所以就是普通函数调用，而因为this指针是 A* const this类型，所以，B的地址传过去，就是基类指针指向父类对象。调用func时，发生多态，调用B的func的函数实现，因为子类重写的是函数实现，而缺省值是用的父类的1，故结果为B->1

> 如果子类重写了缺省值，此时的子类的缺省值是无效的，使用的还是父类的缺省值
> 原因是因为多态是动态绑定，而缺省值是静态绑定。对于P1，他的静态类型也就是这个指针的类型是Base,所以这里的缺省值是Base的缺省值，而动态类型也就是指向的对象是Base1，所以这里调用的虚函数则是Base1中的虚函数，所以这里就是Base1中的虚函数，Base中的缺省值，也就是Base1:10。
>
> **虚函数的重写只重写函数实现，不重写缺省值**。