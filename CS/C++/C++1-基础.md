# 函数重载

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230815202927947.png" alt="image-20230815202927947" style="zoom:150%;" />

C++中引入了一个新特性，函数重载。

在**同一个作用域**下，对于相同的函数名，参数个数、参数类型、参数顺序不同三者中满足其中一个，就是函数重载了（参数名不同，返回值不同不形成重载）

> 函数的重载主要用于处理功能相同，类型不同的数据。

```C++
int test(int i, int j)
{
	cout << "test" << endl;
}

int test(double i, int j)
{
	cout << "test" << endl;
}

int test(double i, int j, int k)
{
	cout << "test" << endl;
}

```

## 为什么C++支持重载，C语言不支持呢？

> C++支持函数重载，而C语言不支持，是因为C++在编译时会进行**函数名修饰（name mangling）**，而C语言不会。
>
> 在C++中，当你声明或者定义一个函数时，编译器会根据函数的参数类型、个数和顺序等信息对**函数名进行修饰**，生成一个唯一的标识符。这个标识符会包含在可执行文件中，**用于在链接时正确地将函数调用与定义相匹配。**
>
> 而在C语言中，没有函数名修饰的概念。如果在C语言中定义了两个同名的函数，编译器无法区分它们，因为函数名是唯一的。这就导致了C语言不支持函数重载。

首先我们要知道，链接器看到有函数被调用的时候，就会到符号表中去查找对应的函数名，来获取函数的地址，再链接到一起

先看C语言是怎么处理的

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410173319299.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410173410156.png)


通过反汇编我们可以看到，**C语言并没有对函数名进行处理，也就是说无论我们参数的个数，参数的类型，参数的顺序怎么修改，它只认函数名，如果出现了第二个相同函数名的，就算重定义。**

下面再看C++的

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410173701451.png)

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410173820912.png" alt="在这里插入图片描述" style="zoom:80%;" />

这里可以看到，C++对函数名进行了处理，函数以\_Z4开头，接着是函数名，最后是所有参数的缩写。
\_Z是所有函数的前缀，4是函数名的字符个数，例如第一个\_Z4testii则代表函数名为test,具有四个字符，参数分别是ii。

这也就是为什么返回值不同和参数名不构成重载的原因，**C++正是通过这种函数名修饰规则来实现函数的重载。**

# extern “C”

有时候我们在使用C++的使用，**对于某些函数想让他按照C的风格来编译，就在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译。**

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410175945239.png)

# 引用

## 引用的概念

**引用是给某一个对象起了另外一个名字，可以通过这个别名来对原对象进行操作，同时编译器不会对引用变量开辟空间，它和它所引用的对象共用一个空间。**

用法：类型 & 引用对象名 = 引用实体

```C++
int main()
{
	int i = 5;
	int& j = i;
	cout << i << ' ' << j << endl;
	j = 8;
	cout << i << ' ' << j << endl;

	return 0;
}

```

## 引用的特性

1. **引用在定义的时候必须初始化**（因为引用是某个对象的别名，所以必须初始化）
2. 一个对象可以有多个引用
3. 一旦引用一个实体，就不能再引用别的实体（有点类似指针的顶层const）

```C++
int i = 0;
int *const p1 = &i;     //  不能改变 p1 的值，这是一个顶层
const int ci = 42;      //  不能改变 ci 的值，这是一个顶层
const int *p2 = &ci;    //  允许改变 p2 的值，这是一个底层
const int *const p3 = p2;   //  靠右的 const 是顶层 const，靠左的是底层 const
const int &r = ci;      //  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const
```

## 常引用

```C++
int main()
{
	const int i = 5;
	int& j = i;
	// 错误的
	const int & k = i;
	// 正确的
    return 0;
}

```

这里对常量i进行引用，因为i是个常量，所以它的值是无法修改的，所以我们使用普通的引用的时候，就会将它的权限放大，导致可以通过j来对i进行修改，这是不合理的，所以编译器会报错。只有使用常量引用才行（权限只能缩小或平移，不能放大）

```C++
int main()
{
	int x = 6;
	const int & y = x;
}
```

同时，我们用常量引用来引用这个x，x是可以修改的，而y无法修改，使权限收缩，变为只读，所以这是可行的。

## 引用的跨类型

```C++
int main()
{
	double x = 3.14;
	int& y = x;   //错误的
	
	const int& z = x;  //正确的
	return 0;
}
```

这里我们分别使用y和z来引用x，但是这时编译器会提示，y报错，z合法，同样是跨类型，为什么会这样呢？

**因为当类型不同的时候会先用一个临时变量来引用x，然后再对这个临时量进行引用**

```C++
int main()
{
	double x = 3.14;
	int& y = x;
	/*
		等价于
		const int &temp = x;
		int &y = temp;
	*/

	const int& y = x;
	/*
		等价于
		const int &temp = x;
		const int &z = temp;
	*/

	return 0;
}
```

如果是普通的引用，这时我们引用的实际上是temp，但是我们是想要对x进行修改的，但是这是不行的，因为**临时量具有常性**，所以这种行为也是非法的。

如果是常量的引用，表明我们不会对x进行修改，所以就算引用的其实是临时量temp，这个行为也是合法的

## 引用的使用场景

### 1.作为参数

```C++
struct A
{
	int arr[1000000];
};

void test(A& s1)
{
}
```

假设我们存在一个超级大的结构体，如果我们直接将结构体传过去的话，会产生一个临时变量来将这个结构体拷贝到形参中，这是极大的开销，但如果我们使用引用的话，传的只是一个别名而已，但是需要注意的是，所以如果我们要传递一个常量，就必须要在引用前加上const。

### 2.作为返回值

```C++
int& Add(int a, int b) 
{
	int c = a + b;
	return c;
}

int main()
{
	int& ret = Add(1, 2);
	Add(3, 4);
	cout << ret << endl;
	return 0;
}
```

对于这样一个代码，我们可能第一眼觉得ret会是3

但是其实是7.

因为我们返回的是c的一个引用，但是c是只存在于调用时的那个栈帧的（局部变量），调用结束后那个栈帧就会被销毁，所以这是一种极为不安全的行为，**如果我们要返回一个引用的话，就必须要保证那个对象出了函数的作用域中还会仍然存在。**
上面的7是第二次调用后修改了c的值。

**所以，如果需要引用作为返回值，就必须保证出了函数作用域，返回的对象没有归还给系统，仍然存在。**

**以值作为参数或者返回值时，在传参和返回的时候，都会传递或返回原变量的一个临时的拷贝，这样的效率是非常低下的，尤其是数据特别大的时候，但如果使用引用作为参数的话，就不会有这样的问题。**

## 引用和指针

前面我们说了，引用是对象的一个别名，没有独立的空间，和其引用的实体共用一个空间，**但是这仅仅是语法概念上的。**同时我们发现，引用其实和指针很像，**它更像一个顶层const的指针**，所以我们可以进入反汇编看看他们之间有没有关系

```C++
int main()
{
	int x = 5;
	int& y = x;
	int* z = &x;

	return 0;
}
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410224332306.png)

**反汇编下我们可以看到，指针和引用在汇编下的实现竟然是一模一样的。**

所以我们可以得出一个结论，**引用是按照指针来实现的，在指针的基础上又给他封装了新的功能**

### 引用和指针的不同点

- 引用在定义时必须初始化，指针没有要求
- 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
- 没有NULL引用，但有NULL指针
- 在sizeof中含义不同：sizeof引用 结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)
- 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
- 有多级指针，但是没有多级引用
- 访问实体方式不同，指针需要显式解引用，引用编译器自己处理，对引用的操作就是对引用所引用对象的操作
- 引用比指针使用起来相对更安全

# 内联函数

**用inline关键字修饰的函数就是内联函数，在编译时编译器会将函数的代码在调用内联函数的地方展开，减去了函数压栈的开销，提升程序运行的效率**

> 例如这样一个简单的代码
>
> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410161425763.png)
>
> 如果我们直接调用它
>
> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410161504429.png)
>
> 在汇编下可以看到，他会创建一个新的栈帧，将参数3,4压栈，然后计算完再返回结果
> 而如果在函数前面加上inline使其变为内联函数
>
> ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410161705570.png)
>
> 这时再看，就会发现它直接把函数的代码在调用处直接展开，不会再创建新的栈帧。

## 内联函数的特性

- **内联函数是一种用空间换时间的做法**，省去了创建栈帧和压栈的开销，但也因此代码很复杂和具有循环或递归之类的函数不适合作为内联函数，就算声明为内联函数编译器也会自动将其忽略。
- **内联函数不能声明和定义分离**，因为一旦声明为内联函数，在调用的时候就会直接展开，没有了函数的地址，就无法将其链接到定义的部分。

值得一提的是，内联函数与C语言中的宏函数有些类似，虽然宏的性能不错，但是因为宏缺乏类型的安全检查和无法调试（在预处理阶段就进行了宏替换），在C++中宏函数被内联函数替代，宏常量定义被const取代。

# auto

> 在编程时我们常常需要把表达式的值赋给变量，但有时我们又不知道表达式的类型是什么，为了解决这个问题，C++11中引入了auto类型说明符，**用它能够让编译器代替我们来分析表达式的所属类型。**

**因为auto需要让编译器通过初始值来推导变量的类型，所以auto类型变量必须要有初始值。**

```C++
int main()
{
	auto i = 2.7;
	cout << i <<"的类型为：" << typeid(i).name() << endl;
}
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410164107331.png)

## auto的使用规则

1. auto可以与指针和引用结合

```C++
int main()
{
	int i = 4;
	auto a1 = &i;
	auto *a2 = &i;
	auto& a3 = i;

	cout <<"a1的类型为：" << typeid(a1).name() << endl;
	cout << "a2的类型为：" << typeid(a2).name() << endl;
	cout << "a3的类型为：" << typeid(a3).name() << endl;
}
```

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410164845587.png" alt="在这里插入图片描述" style="zoom:67%;" />

因为auto可以识别指针类型，所以加不加*都可以，但是引用必须加上&,因为C++没有引用这个类型，引用只是一个修饰别名，所以它的本质还是int。

2. 在同一行定义多个变量
   ```C++
   int main()
   {
   	auto i = 1, j = 2; //正确，同一行都是相同类型
   	auto x = 3, y = 4.8;//错误，同一行类型不同
   }
   ```

3. auto不能作为函数的参数

   ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020041016574272.png)

   auto不能作为形参的类型，编译器无法对i和j的类型进行推导。

4. auto不能直接用来声明数组
   ![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200410165930677.png)

5. auto一般会忽略顶层const
   ```C++
   int main()
   {
   	const int i = 5;
   	//i : const int 
   	auto a1 = i;
   	//忽略了顶层const ,al : int
   	const auto a2 = i;
   	//加上const， a2 : const int
   }
   ```

# 范围for循环

对于一些有范围的集合，我们可能不知道他的长度或者在使用循环的时候不小心越界，c++11为了解决这个问题，引入了范围for循环。

循环分为两部分，第一部分是变量的类型，第二部分是被迭代的范围，两者中间用:隔开.

```C++
int main()
{
	vector<int> vec{ 1, 3, 5, 7, 9 };

	for (auto i : vec)
	{
		cout << i << ends;
	}

}
```

需要注意的是，这里的i是对原数据的拷贝，如果要修改原数据的话需要改成&i（对原数据的引用）