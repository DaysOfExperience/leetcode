# c/c++的动态内存管理

在开始之前首先要了解c和c++的内存分布，我简单的画了一个图

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020042814521658.png)

> 1. 栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。
> 2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共 享内存，做进程间通信。
> 3. 堆用于程序运行时动态内存分配，堆是可以上增长的。
> 4. 数据段–存储全局数据和静态数据。
> 5. 代码段–可执行的代码/只读常量。

**首先，我们需要找到，new/delete与c语言的malloc/free之间有什么区别，为什么有了malloc和free还要实现new和delete呢？new和delete又在malloc和free上有什么改进呢？**

# new/delete

首先来简单介绍一下new和delete的用法

```C++
int main()
{
	int* data1 = new int;
	//动态分配一个int的空间

	int* data2 = new int(15);
	//动态分配一个int的空间，并将它初始化成15

	int* arr = new int[10];
	//动态分配具有10的int的空间

	//这里需要注意[]中写的是该类型数据的个数，而()是初始化的内容

	delete data1;
	delete data2;

	delete[] arr;
	//对于单个数据直接用delete加上名字，如果是多个则需要在delete后面加上[]
}
```

对于内置类型，malloc/free和new/delete的用法类似，功能也差不多，下面来试试自定义类型。

```C++
class Date
{
public:
	Date(int year = 2020, int month = 4, int day = 28)
		:_year(year),
		 _month(month),
		 _day(day)
	{	}
	~Date()
	{
		cout << "调用析构函数" << endl;
	}
private:
	int _year;
	int _month;
	int _day;	
};


int main()
{
	Date* d1 = (Date*)malloc(sizeof(Date));
	//使用c语言的malloc和free
	
	Date* d2 = new Date();
	//使用c++的new和delete
	
	free(d1);
	delete(d2);

	return 0;
}

```

接下来先进入调试，看看他们有什么区别

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020042815151081.png" alt="在这里插入图片描述" style="zoom: 80%;" />

**可以看到d1虽然创建了，但里面都是随机值，而d2自动调用了默认的构造函数。**

然后再看看free和delete

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428151953432.png)

**调用后会发现他们都会清除数据，但是delete会再调用一次析构函数。**

下面来看看他们的汇编有什么不同

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020042815213074.png)

**这里可以看到，它们的基本操作类似，只是new和delete多调用了构造函数和析构函数，但是new还调用了一个operator new，那又是什么呢？**

# opeartor new/operator delete

这里我找来了operator new和delete的代码

> new和delete是**用户进行动态内存申请和释放的操作符**，operator new 和operator delete是**系统提供的全局函数**
>
> **new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。**

```C++
void* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) {
	// try to allocate size bytes
	void* p;
	while ((p = malloc(size)) == 0)
		if (_callnewh(size) == 0)
		{
			// report no memory
			// throw a bad_alloc exception
			static const std::bad_alloc nomem;
			_RAISE(nomem);
		}
	return (p);
}
void operator delete(void* pUserData) 
{
	_CrtMemBlockHeader* pHead;
	RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
	if (pUserData == NULL)
		return;

	_mlock(_HEAP_LOCK); /* block other threads */

	__TRY
		/* get a pointer to memory block header */
		pHead = pHdr(pUserData);
		/* verify block type */
		_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));
		_free_dbg(pUserData, pHead->nBlockUse);

	__FINALLY
		_munlock(_HEAP_LOCK); /* release other threads */
	__END_TRY_FINALLY

	return;
}
```

我们可以看到, opeartor new其实底层调用的还是malloc，但是它改进了一些东西，比如c中分配失误时返回NULL,而它这里是抛出一个异常，operator和free也类似，于是我百度了一下，了解他们为什么要这样实现。

**我得到的结果是，因为c是面向过程，c++是面向对象，这两个函数其实就是从面向过程到面向对象之间的一种过渡，增添了异常和一些内容，再从opeartor new/delete到new/delete又增添了调用构造函数和析构函数，更加符合面向对象的思想。**

# new/delete malloc/free的区别

调用new/delete其实底层会这样实现。

1. 动态分配空间/释放空间(调用operator new/delete->调用malloc/free)
2. 自定义类型（调用构造函数/析构函数）

如果是 new[]/delete[]
则分配/释放一段连续的空间，并且调用n次构造函数/析构函数

**内置类型：**

对于内置类型，new/delete其实和malloc/free基本类似，只不过new和delete失败后会抛出一个bad_allocy异常，而malloc/free会返回一个NULL。
同时new会初始化创建的数据

**自定义类型：**

1. 调用operator new/delete分配空间/释放空间
2. 调用构造函数/析构函数

> malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是：
>
> 1. malloc和free是函数，new和delete是操作符
> 2. malloc申请的空间不会初始化，new可以初始化
> 3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可
> 4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
> 5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常
> 6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间**前**会调用析构函数完成空间中资源的清理

# placement-new

placement-new也就是定位new表达式，**是在已分配的原始内存空间中调用构造函数初始化一个对象。**这一步其实就是new在调用operator new后再执行的那一步。

在实际中我们也会经常使用到定位new表达式，**因为内存池分配出来的内存没有初始化，所以如果是自定义类型的对象，我们需要使用定位new表达式来显式调用构造函数来为其初始化。**

下面介绍一下用法

> 使用格式：
> new (place_address) type或者new (place_address)
> type(initializer-list) place_address必须是一个指针，initializer-list是类型的初始化列表

```C++
int main()
{
	Date* d1 = (Date*)malloc(sizeof(Date));
	new(d1) Date;
	//对于刚刚那个日期类，在使用malloc分配后再用定位new来显式调用构造函数。
	return 0;
}
```

# 内存泄漏(引用)

## 什么是内存泄漏

内存泄漏指因为疏忽或错误造成**程序未能释放已经不再使用的内存的情况。**内存泄漏并不是指内存在物理上的消失，**而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。**

## 内存泄漏的危害：

长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。

> 一般来说，内存泄漏大多数存在于c/c++程序中，因为现在的主流语言如java,python，c#等都具有完善的垃圾回收机制，所以一般不会存在内存泄漏的情况，但也因为这种上述语言存在这种垃圾回收机制，所以在回收内存的时候也会花费宝贵的CPU资源，导致速度有所下降，所以对于c和c++，这是一把双刃剑，全靠程序员如何掌控。

C/C++程序中一般我们关心两种方面的内存泄漏：

1. 堆内存泄漏(Heap leak)
   堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete删掉。**假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用**，就会产生Heap Leak。
2. 系统资源泄漏
   指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。

## 如何避免内存泄漏

1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。
2. 采用RAII思想或者智能指针来管理资源。
3. 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。
4. 出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。 

总结一下: 内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具

# 如何一次性申请4G空间

#### 1.如何一次在堆上申请4G的内存？

因为32位的环境下虚拟地址空间的大小只有4g，而光内核空间就需要1g，所以不可能申请得到，只有在64位的环境下才可以实现，只需要把执行环境改为64x即可

```C++
#include <iostream>
using namespace std;
int main()
{
	void* p = new char[0xfffffffful];
	cout << "new:" << p << endl;
	return 0;
}
```

#### 2.设计一个类，该类只能在堆上创建对象

- **将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。**
- **提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建（借鉴了单例模式）**

**在堆和栈上创建对象都会调用构造函数，为了防止在栈上创建对象我们将构造函数，拷贝构造函数都私有化。**

```C++
class HeapOnly
{
public:
	static HeapOnly* Create()
	{
		return new HeapOnly;
	}
private:
	HeapOnly() {}
	HeapOnly(const HeapOnly&);

	//C++11形式
	HeapOnly(const HeapOnly&) = delete;
};
```

#### 3.设计一个类，该类只能在栈上创建对象

- **只能在栈上创建对象，即不能在堆上创建，因此只要将new的功能屏蔽掉即可，即屏蔽掉operator new和定位new表达式，注意：屏蔽了operator new，实际也将定位new屏蔽掉。**

new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。

operator new函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。

operator delete函数最终是通过free来释放空间的

```C++
class StackOnly
{
public:
	StackOnly()  {};
private:
	void* operator new(size_t size);
	void operator delete(void* p);
};
```

