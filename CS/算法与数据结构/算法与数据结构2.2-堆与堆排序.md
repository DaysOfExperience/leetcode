要点：

堆：物理结构是数组，逻辑结构是完全二叉树

也正是因为是完全二叉树才适合用数组存储。

大根堆：每一颗子树的根节点都大于等于两个孩子   根节点是整棵树最大的

小根堆：每一颗子树的根节点都小于等于两个孩子   根节点是整棵树最小的

关键算法：

1. push：**向上调整算法**（此时除了这个结点，剩余是符合堆结构的
2. pop：先交换，再**向下调整算法**。都不难的其实~~（此时除了交换后的根节点，其余子树是符合根结构的）
3. 整体来说，其实就是两个算法最重要了，AdjustDown&AdjustUp

# 二叉树的顺序结构

普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。

**而完全二叉树更适合使用顺序结构存储**。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。

**完全二叉树的顺序存储**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200301195736145.png" alt="在这里插入图片描述" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200301200438789.png" alt="在这里插入图片描述" style="zoom:67%;" />

**非完全二叉树的顺序存储**
<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/202003012005577.png" alt="在这里插入图片描述" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200301200603687.png" alt="在这里插入图片描述" style="zoom:67%;" />

可以看到，这样是一种对空间的浪费，所以普通的二叉树不适合用数组来存储

# 堆的概念及结构

如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：Ki <= K2i+1 且 Ki<= K2i+2 (Ki >= K2i+1 且 Ki >= K2i+2) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

堆的性质： 

1. 堆中某个节点的值总是不大于或不小于其父节点的值； 
2. 堆总是一棵**完全二叉树。**

![image-20231204230747228](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231204230747228.png)

# 堆的实现

## 堆向下调整算法

**向下调整算法有一个前提：左右子树必须是一个堆**

![image-20231204231040910](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231204231040910.png)

```C++
// size 是总大小，parent是从哪里开始向下调整(下标，因为堆的物理结构是数组）
void Heap::AdjustDown(int size, int parent) {
    // 从parent这里开始向下调整
    int child = parent * 2 + 1;  // 左孩子
    while(child < size) {
        if(child + 1 < size && a[child + 1] > a[child]) {
            // 右孩子存在且右孩子更大，则要判断大根堆，就找出孩子里最大的来判断，因为目标是父是最大的
            child += 1;
        }
        if(a[parent] < a[child]) {
            // 不符合大根堆
            std::swap(a[parent], a[child]);
            parent = child;
            child = parent * 2 + 1;
        }
        else {
            break;
        }
    }
}
```

注意：前提：大根堆，则每次挑出两个孩子（若存在右孩子）中更大的那个，与父节点比较，若父更大，则符合大根堆，则break，若不符合则交换~

## 堆的创建

下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算 法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢？这里我们从**倒数的第一个非叶子节点的子树**开始调整，一直调整到根节点的树，就可以调整成堆。

![image-20231204231134308](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231204231134308.png)

**建堆时间复杂度**：**建堆的时间复杂度为O(N)。**

## 堆的插入push（向上调整算法）

![image-20230817204600499](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230817204600499.png)

其实整体的思想和过程和向下调整非常非常像，几乎没啥差别的。

```C++
void Heap::AdjustUp(int child) {
    // 向上调整。
    int parent = (child - 1) / 2;
    while(child > 0) {
        if(a[parent] < a[child]) {
            std::swap(a[parent], a[child]);
            child = parent;
            parent = (child - 1) / 2;
        }
        else {
            break;  // 此时满足大根堆的条件
        }
    }
}
```

## 堆的删除pop

核心其实就是向下调整算法

**删除堆是删除堆顶的数据**，将堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调整算法。

![image-20230817204754249](C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230817204754249.png)

# 堆的应用

## 堆排序

时间复杂度: O (N*logN)
空间复杂度: O (1)
稳定性：不稳定

堆排序即利用堆的思想来进行排序，总共分为两个步骤：

1. 建堆：O(N)
   升序：建大堆
   降序：建小堆

```C++
// 建堆方式2： O(N)
// 利用向下调整算法：从第一个非叶子结点开始，也就是最后一个叶子结点的父节点开始，到根节点一直向下调整
for (int i = ((n - 1) - 1) / 2; i >= 0; --i)
{
    AdjustDown(a, n, i);
}
```

2. 利用堆删除思想来进行排序

> 建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。

```C++
// 建好堆之后排序 目前是一个小堆，小堆用来排降序
// 利用堆的删除思想来排序
// 5 13 17 19 22 27 32 35 38 42 45
// O(N * LogN);
while(--n) {
    // 进行n-1次删除思想即可
    std::swap(a[0], a[n]);
    AdjustDown(a, n, 0);
}
```

简单来说就是进行n-1次swap，n-1次向下调整即可，注意后续每次向下调整时，传入的堆的个数要减小，因为这里不包括之前已经通过swap交换好的数据。

## TopK问题

TOP-K问题：即求数据集合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。

比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。 

对于Top-K问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了(可能数据都不能一下子全部加载到内存中)。最佳的方式就是用堆来解决，基本思路如下：

1. 用数据集合中前K个元素来建堆
   要求前k个最大的元素，则建小堆
   要求前k个最小的元素，则建大堆
2. 用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素。
   将剩余N-K个元素依次与堆顶元素比完之后，堆中剩余的K个元素就是所求的前K个最小或者最大的元素。

注意这里的不满足则替换堆顶元素：比如要求前10个最大的，则建小堆，且此时堆顶元素就是这10个里面最小的，然后用后面的N-K个依次与堆顶元素比较，若确实比它大，则交换入堆，然后向下调整。最后这10个就是最大的10个，只是说堆顶是这10个里面最小的~

---

以上的所有实现：[Heap.h&&Heap.cpp](https://github.com/DaysOfExperience/data_structure_and_STL/tree/main/data_structure)

