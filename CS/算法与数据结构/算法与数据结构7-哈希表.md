# 1. 哈希，哈希表，哈希函数。

哈希的思想是：**将元素的关键码与元素在哈希表中的存储位置构建某种函数关系，使得查找时，可以通过这个函数，直接获取元素的存储位置。**

对比顺序表和搜索树，顺序表需要将关键码一一对比，时间复杂度为O(N)，而搜索树这样的结构，时间复杂度也是(log_2N)，取决于元素个数，树的高度，同样需要若干次比较。**而哈希可以使得查找元素的存储位置时不需要比较，直接通过哈希函数获取，使得时间复杂度达到了O（1）**。

将这个转换函数称为**哈希函数（散列函数）**，得到的元素的存储位置成为**哈希地址**（也就是在哈希表中的下标，哈希表一般为顺序表结构），将构造出的数据结构成为**哈希表（散列表）**。

# 2. 哈希冲突

难免有某些元素的**不同关键码通过同一个哈希函数转换后得到的哈希地址相同**，这种现象称为**哈希冲突或哈希碰撞**。

故，要想构造出理想的哈希存储结构，**必须解决哈希冲突，合理安排那些关键码不同，而哈希地址相同的元素。**

# 3. 哈希函数

**哈希函数就是建立起元素与其存储位置的映射关系的函数。**

对于哈希函数来说，必须具有以下特点;

- 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间
- 哈希函数计算出来的地址能均匀分布在整个空间中（防止产生密集的哈希冲突）
- 哈希函数应该比较简单（保证效率）

**哈希冲突大量出现往往都是因为哈希函数设计的不够合理，但是即使再优秀的哈希函数，也只能减少哈希冲突的次数，无法避免哈希冲突**

哈希函数有很多种，也就是将元素的关键码，转换为元素存储位置的函数。哈希函数的设计越精妙，产生哈希冲突的概率越低，但是无法完全避免哈希冲突。

## 常见的哈希函数

1. **直接定址法（常见）**
   **哈希函数：Hash（Key）= A\*Key + B**;
   这是最简单的哈希函数，直接取关键字本身或者他的线性函数来作为散列地址。
2. **除留余数法（常见）**
   **哈希函数 ：Hash(key) = key % capacity**
   几乎是最常用的哈希函数，用一个数来对key取模，一般来说这个数都是散列表的容量(capacity。

3.平方取中法，4.折叠法，5.随机数法，6.数学分析法.... (略了)

下方哈希表的实现代码中，采取的哈希函数为除留余数法，即将关键码取模哈希表的长度，获取哈希地址。

## 字符串哈希函数

因为哈希函数的常用方法如直接定址、除留余数、平方取中等方法**需要用的key值都为整型**，**而大部分时候哈希表的key都是string类型**，对于string来说，上面的方法都行不通，因为无法对string进行算数运算，所以需要考虑新的方法。

常见的字符串哈希算法有BKD,SDB,RS等，这些算法大多通过一些公式来对字符串每一个字符的ascii值或者字符串的大小进行计算，来推导出一个不容易产生冲突的哈希地址。

例如BKDHash

```C++
struct _Hash<std::string>
{
	const size_t& operator()(const std::string& key)
	{
		//BKDR字符串哈希函数
		size_t hash = 0;

		for (size_t i = 0; i < key.size(); i++)
		{
			hash *= 131;
			hash += key[i];
		}

		return hash;
	}
};
```

# 3. 解决哈希冲突的两大方法：闭散列，开散列

## 闭散列（开放定址法）

闭散列：也叫开放定址法。核心思想比较简单：若某两个元素发生哈希冲突，第二个得到该哈希地址的元素插入时，将该元素存放到哈希表中发生哈希冲突的“下一个”空位置中去。其实也就是再找一个空位置，然后插入。

寻找下一个“空位置”的方法有两种

1. 线性探测，即从哈希地址处起，逐个位置进行判断，直到找到空位置。
2. 二次探测：第一次看hashAdd+0^2下标处有没有被占用（设哈希地址为hashAdd。其实也就是看获取的哈希地址处有没有没被占用），第二次看hashAdd+1^2，第三次看hashAdd+2^2，直到找到没有被占用的位置。

相比于线性探测，二次探测只是将发生哈希冲突的元素的存储位置分离一些，不像线性探测一样连续存储，**故二次探测能一定程度减少哈希冲突带来的性能损耗，但是不能根本解决问题。**

### 闭散列的删除问题

![img](https://img-blog.csdnimg.cn/73f1e9d1fa6445b68fc96536e68b7175.png)

如上哈希表中，关键值4和44采取除留余数法哈希函数获取的哈希地址相同，都是4，最后插入44时，向后找空位置，无论是线性探测还是二次探测，都会插入到哈希表中哈希地址（下标）为8处。

此时，若删除5（或者4，6，7），再查找44，就会影响44的查找（因为实际上44是存在的，但是因为线性探测探测到中间有位置为空（被删了），就会以为44key不存在）
故在闭散列的哈希表实现中，哈希表中每个存储位置的存储状态，包括：存在EXIST，删除DELETE，空EMPTY。查找44时，不能因为5位置为删除就停止线性探测查找，也就是遇到DELETE不停。（看代码）。线性探测采用标记的伪删除法来删除一个元素。

### 负载因子

负载因子为哈希表中的元素个数/哈希表长度。

负载因子越大，同样长度的哈希表存储的元素越多，发生哈希冲突概率越大，查找时效率越低，但是空间使用率越高。

负载因子越小，同样长度的哈希表存储的元素越少，发生哈希冲突概率越小，查找时效率越高，但是空间使用率越低。

理论上，采取闭散列的哈希表的最大负载因子为1，负载因子为1时必须扩容。但是，闭散列哈希表当负载因子超过0.8时，查表时CPU缓存不命中按照指数曲线上升。故，负载因子需要取一个合适的值，对于闭散列（开放定址法）的哈希表，负载因子非常重要，应控制在0.7 ~ 0.8以下，若超出，即需要扩容哈希表，并且增容后，为了保证映射关系，还需要将数据重新映射到新位置。（元素的哈希地址随着哈希表大小的改变而改变）

> 因为除留余数法等方法通常是按照表的容量来计算，所以科学家的计算，当对一个质数取模时，冲突的几率会大大的降低，并且因为增容的区间一般是1.5-2倍，所以算法科学家列出了一个增容质数表，按照这样的规律对哈希表增容，冲突的几率会大大的降低。
>
> 这也是STL中unordered_map/unordered_set使用的增容方法。
>
> ```C++
> //算法科学家总结出的一个增容质数表，按照这样增容的效率更高
> const int PRIMECOUNT = 28;
> 
> const size_t primeList[PRIMECOUNT] = 
> {
>  53ul, 97ul, 193ul, 389ul, 769ul,
>  1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
>  49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
>  1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
>  50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
>  1610612741ul, 3221225473ul, 4294967291ul
> };
> ```

## 开散列（链地址法）

开散列是另一种解决哈希冲突的方法。又称**链地址法**

核心思想是：首先对关键码集合用散列函数计算散列地址，**具有相同哈希地址的关键码（发生哈希冲突）归于同一子集合，每一个子集合称为一个哈希桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。**

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230822123902091.png" alt="image-20230822123902091" style="zoom:67%;" />

哈希表代码实现中，哈希表数组存储的是结点指针（结点封装数据和单链表next指针）。

**开散列的哈希表中每个哈希桶存放的都是发生哈希冲突的元素。**

### 开散列的负载因子和扩容问题

注意：哈希表是需要扩容的，而是否扩容的衡量指标就是负载因子。(当元素个数/哈希表容量 >= 负载因子时，对哈希表进行扩容)

**开散列中，当负载因子为1时，也就是理想情况下每个哈希桶中只挂一个元素时，进行扩容。**

因为再继续插入元素时，每一次都会大概率发生哈希冲突，而开散列哈希表中若一个桶中的元素个数比较多时，会影响哈希表的性能。理想情况就是每个哈希桶中只挂一个元素，此时搜索时间复杂度为O(1)。

## 开散列和闭散列的比较

> 开放定址法和链地址法都是用于解决哈希表中冲突（碰撞）的方法。它们在处理冲突时有不同的方式，因此各自具有一些优点和缺点。
>
> **开放定址法：**
>
> 开放定址法是一种冲突解决方法，其中发生冲突时，将数据项插入到下一个可用的位置，直到找到一个空槽为止。以下是开放定址法的一些优缺点：
>
> **优点：**
>
> 1. **内存利用率高：** 开放定址法中，数据项都存储在哈希表中，没有额外的链表或其他数据结构，因此可以更有效地利用内存空间。
> 2. **缓存友好：** 由于**数据是紧密存储**在哈希表中的，所以在某些情况下可以更好地利用 CPU 缓存，从而提高访问效率。
> 3. **简单：** 开放定址法的实现相对简单，不需要额外的指针或链表操作。
>
> **缺点：**
>
> 1. **聚集问题：** 开放定址法容易导致聚集问题，即**连续的哈希冲突**可能会导致哈希表中出现大量的空槽，**影响性能。**
> 2. **删除困难：** 删除数据项时需要考虑空槽的处理，可能需要特殊的标记来表示槽位是否为空或已删除。
> 3. **依赖好的散列函数：** **开放定址法对于散列函数的选择比较敏感**，不好的散列函数可能会导致冲突更频繁。
>
> **链地址法：**
>
> 链地址法使用一个数组，每个槽位存储一个链表或其他数据结构，用于存储哈希冲突的数据项。以下是链地址法的一些优缺点：
>
> **优点：**
>
> 1. **灵活处理冲突：** 链地址法能够有效地处理冲突，通过在同一个槽位上存储一个链表或其他数据结构，**可以灵活地添加、删除和查找数据项。**
> 2. **相对低的聚集问题：** 由于每个槽位可以存储多个数据项，**链地址法相对开放定址法在聚集问题上表现较好。**（对于哈希冲突的处理更好
> 3. **适用于动态大小：** 链地址法更适合动态大小的哈希表，因为添加或删除数据项时，不需要考虑数据的移动。
>
> **缺点：**
>
> 1. **内存占用较高：** 链地址法需要额外的指针或链表结构来管理每个槽位上的数据，因此可能会占用更多的内存。
>    （错误，应用链地址法（开散列）处理哈希冲突，需要增设链接指针，似乎增加了存储开销。
>    事实上： 由于开放定址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子a <= 0.7，而表项所占空间又比指针大的多，**所以使用链地址法反而比开地址法节省存储空间。**）
> 2. **缓存效率较低：** 由于数据存储在不同的链表中，可能会导致访问时的缓存不命中，从而降低访问效率。
> 3. **链表操作开销：** 对于小规模数据，链表操作可能会引入一定的开销，**例如插入和查找时需要遍历链表。**
>
> 综上所述，选择开放定址法还是链地址法取决于具体应用的需求和性能要求。**开放定址法适合内存效率高、简单场景**，**而链地址法适用于需要更好的冲突处理和动态调整大小的场景。

# 4. 开散列&闭散列哈希表代码实现

[HashTable](https://github.com/DaysOfExperience/data_structure_and_STL/tree/main/data_structure)