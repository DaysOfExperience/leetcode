# 排序的概念

**排序：**所谓排序，就是使一串记录，**按照其中的某个或某些关键字的大小**，**递增或递减的排列起来**的操作。

**稳定性：**假定在待排序的记录序列中，存在**多个具有相同的关键字**的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

**内部排序：数据元素全部放在内存中的排序。**

**外部排序：**数据元素太多不能同时放在内存中，根据排序过程的要求不断在内外存之间移动数据的排序。

# 常见排序算法

插入排序

1. 直接插入排序
2. 希尔排序

选择排序

1. 选择排序
2. 堆排序

交换排序

1. 冒泡排序
2. 快速排序

归并排序

1. 归并排序

# 插入排序

**把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。**

插入排序的核心 “**将未排序数据一个个插入进已排序的数据中**”

> 实际上我们玩扑克牌时就是一个典型的插入排序的思想：我们手中的是一个已经排好序的有序序列，每次从未排序的序列中选出一个新的元素插入到有序序列的合适位置中。

## 直接插入排序

当插入第i(i>=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。

插入排序在实现上，通常采用**in-place**排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**算法描述：**

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

![动图](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)

```C++
// 直接插入排序
void InsertSort(int arr[], int n)
{
    if(n == 0) {
        return;
    }
    int current = 0;
    for(int i = 0; i < n - 1; ++i) {
        current = arr[i + 1];     // 要插入的新元素，且[0, i]是有序序列
        int preIndex = i;   // 从preIndex处开始向前扫描
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            --preIndex;
        }
        arr[preIndex + 1] = current;
    }
}
// 直接插入排序
void InsertSort(int arr[], int n)
{
// 23819
    for(int i = 1; i < n; ++i) {
        int newNum = arr[i];
        // i下标是新元素，在[0,i-1]下标中进行从后向前的扫描，找到合适的位置进行插入
        for(int j = i - 1; j >= 0; --j) {
            if(arr[j] > newNum) {
                arr[j + 1] = arr[j];  // 当第一次比较时，这里直接他妈的把新要插入的元素覆盖了
                if(j == 0) {
                    arr[0] = newNum;    // 直接将新元素插入到0下标处
                }
            }
            else {
                arr[j + 1] = newNum;   // 新元素插入到合适的位置
                break;
            }
        }
    }
}
```

直接插入排序的特性总结： 

1. 元素集合越接近有序，直接插入排序算法的时间效率越高 
2. 时间复杂度：**最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2)**
3. 当集合接近有序或完全有序时，插入排序时间复杂度接近O(N)
4. 空间复杂度：O(1)
5. 稳定性：稳定，它是一种稳定的排序算法

## 希尔排序（缩小增量排序）

> 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。希尔排序又叫缩小增量排序。

> 利用插入排序的第三个特点，所以希尔排序效率高。
>
> 希尔排序高效的原因就是：用比较少的时间将集合排为接近有序，最后再插入排序时，即为接近O(N)。

![ss](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/v2-9c0b7cda43bb32c4c206d545a3409c80_720w.webp)

> 整体思想：希尔排序等于若干次的直接插入排序，有一个gap值，初始时gap较大。每一次全部元素的直接插入排序，都是将所有元素按照gap进行分组，初始时gap较大，分组较多。对于每一组都进行一次直接插入排序。当所有组都进行完毕，则第一次全部元素的直接插入排序完成。
>
> gap逐渐减小，分组数量减小，每一组的元素增多。当最终gap==1时，只有一组，一组为全部元素。

> 结合下方代码：
>
> 1.我们肯定是要进行若干次的直接插入排序的，gap逐渐减小，也就是while。而内部的for就是一次'按照gap分好组之后的全部组的直接插入排序'，按理来说，按照希尔排序的思想来说，我们需要对按照gap分好组的每组进行直接插入排序，也就是一次全部元素的直接插入排序 = 组数量次的直接插入排序。但是实际上我们不需要这样。
> （这里其实是理解代码的核心，因为shellsort中并不是每一组进行一次insertsort再换一组~~~）
>
> 2.观察for：i初始时是gap，其实本质就是第一组的第二个元素的下标。而i++之后就是第二组的第二个元素的下标了~
> 所以其实整个for是：第一组进行一次新元素的插入，再换一组第二组进行一次新元素的插入。
> 对照上图：第一次的35460是新元素，需要插入他们组的已经排好序的有序序列中。
> 第二次的16089472是需要插入的新元素~
>
> **其实for就是之前的InsertSort的1换为gap**
>
> 3.for循环内部，需要理解的是：preIndex和current相距gap，这里面的每一次处理都是和gap相关的，而不是InsertSort里面的1~（当gap==1时，其实就是一次正宗的直接插入排序）

```C++
void ShellSort(int *arr, int n) {
    int current = 0;   // 存储每次要新插入的元素
    int gap = n / 2;   // 增量：每隔gap的元素分为一组，一组内进行直接插入排序~
    while(gap > 0) {
        // 下面的for循环是一次的，对所有分组进行直接插入排序
        // 对比InsertSort：只需要将原来的步长1改为gap即可实现
        for(int i = gap; i < n; ++i) {
            current = arr[i];    // 此时要插入的新元素
            int preIndex = i - gap;
            while(preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            arr[preIndex + gap] = current;
        }
        gap /= 2;   // 减小缩量~
    }
}
```

1. 希尔排序是对直接插入排序的优化。
2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。
3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些书中给出的希尔排序的时间复杂度都不固定。**时间复杂度：最好情况O(n^1.3) 最坏情况O(n^2)，空间复杂度：O(1)**
4. 稳定性：不稳定
5. 关于gap的选择：gap越大，越不接近有序，跳的越快；gap越小，越接近有序，跳的越慢。
6. gap越大预排越快,预排后越不接近有序，gap越小预排越慢,预排后越接近有序
7. 一般初始时，gap = length / 3 + 1;

# 选择排序

> 表现**最稳定的排序算法之一**，因为**无论什么数据进去都是O(n2)的时间复杂度**，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

基本思想： 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在待排序序列的起始位置，直到全部待排序的数据元素排完 。

## 直接选择排序

算法描述（步骤）:略了，比较简单

![zzz](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.webp)

```C++
void SelectSort(int* arr, int n) {
    // 直接选择排序
    // 选择n-1次即可，最后只剩一个元素是不需要
    for(int i = 0; i < n; ++i) {
        int minIndex = i;
        for(int j = i; j < n; ++j) {   // 从[i, n-1]选择
            if(arr[j] < arr[minIndex])  minIndex = j;
        }
        // minIndex是[i, n-1]里面最小的元素的下标
        if(i != minIndex)
            std::swap(arr[minIndex], arr[i]);
    }
}
```

直接选择排序的特性总结： 

1. 直接选择排序非常好理解，但是效率不是很好。**实际中很少使用**
1. 时间复杂度：**最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)**（纯纯的O(N^2)）
1. 空间复杂度：O(1)
1. 稳定性：不稳定

> 还有一个改进版，其实就是每次选出一个max和min，具体略了

## 堆排序

堆：顺序结构存储的完全二叉树，符合某种特性：根节点大于/小于其孩子结点，大于则大堆，小于则小堆

升序建大堆，降序建小堆，每次选出一个最大/最小，然后放置数组/二叉树的尾部。符合选择排序的思想：每次选择出一个最大/最小元素

堆排序特性总结：

1. 堆排序使用堆来选数，效率就高了很多。 
2. 时间复杂度：**最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)**
3. 空间复杂度：O(1)
4. 稳定性：不稳定

具体看'算法与数据结构2.2-堆与堆排序.md'

# 交换排序

基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置

交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。

## 冒泡排序

> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
>
> 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。

![bubbleS](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/%E5%86%92%E6%B3%A1.gif)

```C++
void BubbleSort(int* arr, int n) {
    // 外层for是次数，一共n-1次冒泡即可
    for(int i = 0; i < n - 1; ++i) {
        bool flag = false;   // 8 1 2 3 5 7
        // ↓ 一次冒泡
        for(int j = 0; j < n - 1 - i; ++j) {
            if(arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                flag = true;
            }
        }
        if(!flag) break;
    }
}
```

每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。

冒泡排序的特性总结：

1. 冒泡排序是一种非常容易理解的排序
2. 时间复杂度：**最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)**
3. 空间复杂度：O(1) 
4. 稳定性：稳定

## 快速排序

其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后对左右子序列重复该过程，直到所有元素都排列在相应位置上为止。

快速排序单趟的思路，就是先选定某个枢轴，以这个枢轴为基准，展开划分，划分的结果为：这个枢轴的左边的数据全都比它小，右边的数据全都比它大。划分后枢轴的位置也就是它的最终位置，这样就完成了枢轴的归位。

### Hoare版本快排

（Hoare：快排的发明者）

口诀: 右边找小, 左边找大, 交换, 交换

```c++
//  Hoare 版本
void QuickSort(int* arr, int begin, int end) {  // [begin, end]
    int left = begin;
    int right = end;
    int keyIndex = begin;  // 设置下标是因为后面要交换数据
    while(left < right) {
        // 右边找小
        while(left < right && arr[right] >= arr[keyIndex]) {
            right--;
        }
        // 左边找大
        while(left < right && arr[left] <= arr[keyIndex]) {
            left++;
        }
        // 这里不管是否left<right都交换，等于也无妨。
        swap(arr[left], arr[right]);
    }
    // 这里出循环之后，一定符合left == right。
    swap(arr[keyIndex],arr[left]);
    // 单趟排序结束，此时left下标处的值为枢纽值，左边小于它，右边大于它
    // [begin, left-1] left [left+1, end]
    if(left - 1 > begin)
        QuickSort(arr,begin,left-1);
    if(left + 1 < end)
        QuickSort(arr,left+1,end);
}
```

> 单趟排序的目的：找一个key，单趟排序结束后key的左边比它小，右边比它大，这样为一次单趟排序。
>
> 这里暂时先不使用三数取中的优化，则先找一个key值（一般为最左边或最右边），这里默认为left下标处的值。然后定义left，right。右边找小于key的值，左边找大于key的值，且必须是right先走。（这里有原因，后序解答）。当右边找到小，左边找到大，交换左右下标的值，使得大于key的大值去右边，小于key的小值去左边。当left和right相遇之后循环退出，再交换key下标的值，和相遇处的值（这里取left和right都可以） 至此，单趟排序结束。

> 细节1：右边一定要找小于key的值，左边一定要找大于key的值，也就是while循环中必须为arr[right]>=arr[key]。不可以为arr[right] > arr[key]  为了防止如下情况：5 5 1 2 3 4 5 这样就会陷入死循环。
>
> 细节2：每个循环都要写left<right这个条件。而不管在任何一个循环处达到了left=right  都可以正常停下，while里的swap也只是原地交换，然后退出大的while。

> 为什么key在左边必须右边先走（right先找小于key的值）？
> 答：因为只有右边先走才可以达成left，right相遇处的值<= arr[key]，这样swap(arr[key], arr[left])之后，<=arr[key]的值去了左边才符合最终单趟排序的规定
> 具体情况：情况1：right--，碰到left，此时left下标处的值要么为上次swap之后的值，也就是小于key。要么left根本就没走，也就是arr[left]的右边的所有值都大于等于arr[left]（key），这样是符合期望的。
> 情况2：left++，碰到right，此时right一定是while循环之后找到了小于key的值，这样相遇处的值依旧符合<key。
> 综上，在相遇之后，相遇处的值和key的值交换之后，符合单趟排序的最终期望。

> 单趟排序结束后，进行递归，这里类似于二叉树的前序遍历：对根节点进行处理，然后递归左子树，左子树递归完递归右子树。而这里是递归左区间，然后递归右区间。当左右区间都有序了，整体也就有序了。
>
> 不过要注意，这里是递归左区间，然后左区间的左区间，无限递归下去，当某一次左区间的元素个数<=1 时，停止递归，再返回回去递归右区间。（可以想象二叉树的前序遍历。）

> 注意QuickSort的left和right 是左闭右闭形式的。也就使得，单趟排序之后，整个区间被划分为了[begin, left-1] left [left+1, end]  也就得出了递归的条件： left-1 > begin   left+1 < end。（保证区间至少有两个元素才进一步递归进行sort）左闭右开的话情况类似，需要改变右递归条件为 left+1 < end-1 注意这里的left的值是交换之后的，最初的key值。你也可以把left赋值给key key = left 然后用key去划分这个区间。

```C++
// 挖坑法
void QuickSort(int* arr,int begin, int end) { // [begin, end]
    int left = begin, right = end;  // left和right为范围，因为最后还要使用begin和end进行递归。
    int key = arr[left];  // arr[key] 保存元素值而不是下标是因为left下标的值会被改变。单趟排序的最后要把这个元素值放入最后一个坑中。
    while(left < right) {
        // 右边找小，填入坑中
        while(left < right && arr[right] >= key) {
            right--;
        }
        arr[left] = arr[right];
        // 左边找大， 填入坑中
        while(left < right && arr[left] <= key) {
            left++;
        }
        arr[right] = arr[left];
    }
    arr[left] = key; // left == right
    // 下面的left就是最终的key值所在位置。
    if(left - 1 > begin)
        QuickSort(arr, begin, left - 1);
    if(left + 1 < end)
        QuickSort(arr, left + 1, end);
}
```

这里的key是左下标的值，而不是左下标。因为这里的值会被覆盖。

总结：右边找小，填入左边，左边找大，填入右边。相遇之后，将相遇点的值改为key。

```C++
// 前后指针法
略了，不想弄了
```

### 快速排序优化

三数取中优化：我们取begin处的值为key值，若begin处的值为序列中的最小值（较小值），最大值（较大值），此时快排的效率会降低，因此，三数取中指的是取出begin end mid三处的中间值，作为key（直接将其放在begin处即可）

直接插入优化：若待排序的序列的元素个数<=12，此时快排的效率不如直接插入排序。

```C++
// 我们选择的枢纽是begin位置，所以下方函数使得begin，mid，end三处最终begin为中间值
void optimize(int *arr, int begin, int end) {
    int mid = ((end - begin) >> 1) + begin;
    if(arr[mid] > arr[end]) {
        std::swap(arr[mid], arr[end]);
    }
    if(arr[begin] < arr[mid]) {
        std::swap(arr[begin], arr[mid]);
    }
    if(arr[begin] > arr[end]) {
        std::swap(arr[begin], arr[end]);
    }
}
//  Hoare 版本
void QuickSortHoare(int* arr, int begin, int end) {  // [begin, end]
    if(end - begin <= 12) {
        return InsertSort(arr + begin, end - begin + 1);
    }
    optimize(arr, begin, end);   // 调用之后begin下标处的值为中间值，优化
    int left = begin;
    int right = end;
    int keyIndex = begin;  // 设置下标是因为后面要交换数据
    while(left < right) {
        // 右边找小
        while(left < right && arr[right] >= arr[keyIndex]) {
            right--;
        }
        // 左边找大
        while(left < right && arr[left] <= arr[keyIndex]) {
            left++;
        }
        // 这里不管是否left<right都交换，等于也无妨。
        swap(arr[left], arr[right]);
    }
    // 这里出循环之后，一定符合left == right。
    swap(arr[keyIndex],arr[left]);
    // 单趟排序结束，此时left下标处的值为枢纽值，左边小于它，右边大于它
    // [begin, left-1] left [left+1, end]
    if(left - 1 > begin)
        QuickSortHoare(arr,begin,left-1);
    if(left + 1 < end)
        QuickSortHoare(arr,left+1,end);
}
```

### 快排非递归

```C++
// 快排改非递归用循环很难，可以在堆上创建数据结构：栈 来模拟递归过程。(因为堆很大
void QuickSortNoRecursionStack(int* arr, int begin, int end)  // recursion  [begin, end]
{
    stack<int> st;
    st.push(end);
    st.push(begin);
    while(!st.empty()) {
        int bg = st.top(), left = bg;
        st.pop();
        int ed = st.top(), right = ed;
        st.pop();
        optimize(arr, left, right);
        int keyIndex = left;
        while(left < right) {
            while(left < right && arr[right] >= arr[keyIndex]) {
                --right;
            }
            while(left < right && arr[left] <= arr[keyIndex]) {
                ++left;
            }
            std::swap(arr[left], arr[right]);
        }
        std::swap(arr[left], arr[keyIndex]);
        // 单趟排序结束，接下来处理左右子区间
        if(left - 1 > bg) {    // [bg, left - 1]
            st.push(left - 1);
            st.push(bg);
        }
        if(left + 1 < ed) {  // [left + 1, ed]
            st.push(ed);
            st.push(left + 1);
        }
    }
}
```

先压右区间，后压左区间。这样整体过程就是前序遍历，也就是递归版的快排。

```C++
void QuickSortNoRecursionQueue(int* arr, int begin, int end) {
    queue<int> que;
    que.push(begin);
    que.push(end);
    while(!que.empty()) {
        int bg = que.front(), left = bg;
        que.pop();
        int ed = que.front(), right = ed;
        que.pop();
        optimize(arr, left, right);
        int keyIndex = left;
        while(left < right) {
            while(left < right && arr[right] >= arr[keyIndex]) {
                --right;
            }
            while(left < right && arr[left] <= arr[keyIndex]) {
                ++left;
            }
            std::swap(arr[left], arr[right]);
        }
        std::swap(arr[left], arr[keyIndex]);
        // 单趟排序结束，接下来处理左右子区间
        if(left - 1 > bg) {    // [bg, left - 1]
            que.push(bg);
            que.push(left - 1);
        }
        if(left + 1 < ed) {  // [left + 1, ed]
            que.push(left + 1);
            que.push(ed);
        }
    }
}
```

递归版的快排是递归处理左区间，也就是二叉树的前序遍历的逻辑。而这里的用队列模拟的过程中是有所改变的，先处理左半区间，此时再循环时就是处理右半区间，下一次处理左半区间的左半区间，左半区间的右半区间。右半区间的左半区间，右半区间的右半区间。
也就是二叉树的层序遍历的逻辑~~~

![](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230820155159359.png)

### 快速排序的特性总结：

1. 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序
1. 时间复杂度：**最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn)　**
1. 空间复杂度：O(logN)
1. 稳定性：不稳定

# 归并排序

## 归并排序（Merge Sort）

和选择排序一样，归并排序的性能不受输入数据的影响（稳定排序），但表现比选择排序好的多，因为始终都是O(n*logn）的时间复杂度。代价是需要额外的内存空间。

归并排序是建立在**归并操作**上的一种有效的排序算法。该算法是采用**分治法**（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2路归并。

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230820165924681.png" alt="image-20230820165924681" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序" style="zoom:67%;" />

### 递归版

```C++
void _MergeSort(int *arr, int begin, int end, int *tmp) { // [begin, end]
    // 二叉树后序遍历思想：先让左右区间有序，再二路归并O(N)
    int mid = ((end - begin) >> 1) + begin;   // 若mid == begin，则此时只有两个元素了，此时无需再次递归，直接进行两个元素的归并操作即可
    if(begin < mid)   _MergeSort(arr, begin, mid, tmp);    // [begin, mid]
    if(mid + 1 < end)   _MergeSort(arr, mid + 1, end, tmp);     // [mid + 1, end]
    // 此时左右区间都有序了：[begin, mid] [mid + 1, end]，下面进行O(N)的归并
    int index = begin;
    int begin1 = begin, end1 = mid;
    int begin2 = mid + 1, end2 = end;
    while(begin1 <= end1 && begin2 <= end2) {
        if(arr[begin1] < arr[begin2]) {
            tmp[index++] = arr[begin1++];
        } else {
            tmp[index++] = arr[begin2++];
        }
    }
    while(begin1 <= end1) tmp[index++] = arr[begin1++];
    while(begin2 <= end2) tmp[index++] = arr[begin2++];
    memcpy(arr + begin, tmp + begin, (end - begin + 1) * sizeof(int));
}
void MergeSort(int *arr, int n) {
    int *tmp = new int[n];
    _MergeSort(arr, 0, n - 1, tmp);
    delete []tmp;
}
```

核心思想：先使左右区间有序，再用O(N)的二路归并操作即可。

归并排序的过程和思想非常符合二叉树的后序遍历，先遍历左右子树，后处理根节点。

10 6 7 1 3 9 4 2，左右区间各4个，再分为22的子区间，再分为11的子区间，当区间只有1个元素时，代表已经有序，此时11区间进行归并。22区间进行归并，44区间进行归并。

具体来说，是符合二叉树的后续遍历的，即先处理44的左，再处理4的22的左，当序列有两个元素时，不需要再进行递归（也可以递归进去，发现此时区间为1个元素直接return，上方采用的是不再递归的方式，可以减少函数栈帧开辟），两个元素归并，4的右区间2个元素进行归并，再返回，4的区间进行二路归并，此时再处理8分44的右半区间（也就是最初的\_MergeSort的第二个\_MergeSort的递归）。类比二叉树的根节点的右子树~

二路归并时：并非是在原空间上直接进行，而是先归并到一个新的空间中，再将有序序列拷贝到原空间中，因此MergeSort的空间复杂度较高。（上图中横线上方是递归的过程，横线下方是O(N)的归并过程）

**归并排序的特性总结：** 

1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。
2. 时间复杂度：O(N*logN)
3. 空间复杂度：O(N)
4. 稳定性：稳定

### 非递归版

```C++
void MergeSortNoRecursion(int* arr, int n) {
    int *tmp = new int[n];
    int gap = 1;  // 起初11归并
    while(gap < n) {
        for (int i = 0; i < n; i += gap * 2) {
            // [i, i+gap-1] [i+gap, i+2*gap-1]  这两个区间进行O(N)的二路归并
            int begin1 = i, end1 = i + gap - 1;
            int begin2 = i + gap, end2 = i + 2 * gap - 1;
            // 此时，end1 begin2 end2可能越界，最简单的比如n = 10 最终88归并：0 7 8 15此时end2越界
            if(end1 >= n) {  // end1越界，不需要二路归并，直接将[begin1, n-1]拷贝回去即可，
                end1 = n - 1;
                // 右区域数组改为不存在的范围，从而下面的归并逻辑就只会把[begin1, end1]拷贝到tmp的对应位置中
                begin2 = 2;
                end2 = 1;   // 破坏begin2 <= end2的条件
            }else if(begin2 >= n) {  // begin2越界(说明end1就是n-1)，此时依旧不需要二路归并，且[begin1, end1]本来就是有序的
                // 右区域数组改为不存在的范围，从而下面的逻辑就只会把[begin1, end1]拷贝到tmp中
                begin2 = 2;
                end2 = 1;
            }else if(end2 >= n) {  // end2越界，需要二路归并，只是不是相等数量的二路归并罢了，比如43  86
                end2 = n - 1;
            }
            int index = i;
            while (begin1 <= end1 && begin2 <= end2) {
                if (arr[begin1] < arr[begin2]) tmp[index++] = arr[begin1++];
                else tmp[index++] = arr[begin2++];
            }
            while (begin1 <= end1) tmp[index++] = arr[begin1++];
            while (begin2 <= end2) tmp[index++] = arr[begin2++];
            // [i, i+gap-1] [i+gap, i+2*gap-1]两个区间的二路归并完毕
        }
        // gapgap归并完毕（11，22，44）
        memcpy(arr, tmp, n * sizeof(int));
        gap *= 2;
    }
    delete[] tmp;
}
```

先11归并：每1个元素为一组，每两组进行归并到tmp，从左至右依次每两组进行归并，然后全部11完毕，再拷贝回原空间。再22归并：每2个元素为1组，每两组进行一次归并，从左至右依次进行。再44，88

值得注意的是：此处[i, i+gap-1] [i+gap, i+2*gap-1]这两个区间的范围可能越界，若越界需要进行对应的调整，见代码注释即可，很简单
。简单来说就是：只有当第二个区间的end越界时，才需要进行数量不对等的归并。若i+gap-1 i+gap越界，此时直接进行简单处理，然后归并的逻辑就是将有序的[i, n-1]归并（拷贝）到tmp，最终再统一拷贝回去~

```C++
void MergeSortNoRecursion2(int* arr, int n) {
    int* tmp = (int*)malloc(n*sizeof(int));
    if(tmp == nullptr) {
        cout<<"MergeSortNoRecursion::malloc fail"<<endl;
        exit(-1);
    }
    int gap = 1;
    while(gap < n) {
        for(int i = 0; i < n; i += 2 * gap) {  // 2*gap是一组排完序的个数，到下一组了。
            // [i, i+gap-1] [i+gap, i+2*gap-1]  对这两个范围内的数据进行排序。
            // begin1=i不可能越界，只有end1，begin2，end2可能越界。
            int begin1 = i, end1 = i + gap - 1;
            int begin2 = i + gap, end2 = i + 2 * gap - 1;

            //越界检查，修改后其实还是基于下面的归并逻辑以及memcpy的位置。
            if(end1 >= n) {
                break;
            }else if(begin2 >= n) {
                break;
            }else if(end2 >= n) {
                // 这种情况，比如一共10个元素，此时gap为8，则表示这是最后一次归并
                // 那么只有end2越界，此时需要归并，只是一个不对称的归并而已
                end2 = n-1;
            }
            int copyNum = end2 - begin1 + 1;
            // 对[i, i+gap-1] [i+gap, i+2*gap-1]范围内进行归并
            int index = begin1;
            while (begin1 <= end1 && begin2 <= end2) {
                if (arr[begin1] < arr[begin2]) {
                    tmp[index++] = arr[begin1++];
                } else {
                    tmp[index++] = arr[begin2++];
                }
            }
            while(begin1 <= end1) {
                tmp[index++] = arr[begin1++];
            }
            while(begin2 <= end2) {
                tmp[index++] = arr[begin2++];
            }
            memcpy(arr+i, tmp+i, copyNum*sizeof(int));
        }
        // 全部归并完，再全部拷贝回去。
        gap *= 2;
    }
    free(tmp);
}
```

不想看就不看了，只是每一组归并到tmp之后立即拷贝回去，上一个方法是全部归并到tmp之后再拷贝回去。使得越界处理会变得简单一点~

# 非比较排序：计数排序

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，**计数排序要求输入的数据必须是有确定范围的整数。**

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。**它只能对整数进行排序。**是对哈希直接定址法的变形应用。

**算法描述**

- 找出待排序的数组中最大和最小的元素；开辟计数空间大小为max - min + 1
- 统计数组中每个值为i的元素出现的次数，存入计数数组的第i项；
- 反向填充目标数组

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/count.gif" alt="count sort" style="zoom:67%;" />

```C++
void CountSort(int *arr, int n) {
    int min = arr[0], max = arr[0];
    for(int i = 0; i < n; ++i) {
        if(arr[i] < min) min = arr[i];
        if(arr[i] > max) max = arr[i];
    }
    int range = max - min + 1;
    int *count = new int[range];
    for(int i = 0; i < range; ++i)  count[i] = 0;
    for(int i = 0; i < n; ++i)  count[arr[i] - min]++;
    int index = 0;
    for(int i = 0; i < range; ++i) {
        while(count[i]-- != 0) {
            arr[index++] = i + min;
        }
    }
}
```

当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

**计数排序的特性总结：**

1. 计数排序在数据范围集中时，效率很高，但是适用范围及场景有限。
2. 时间复杂度：O(MAX(N,范围))
3. 空间复杂度：O(范围)
4. 稳定性：稳定

# 总结

![image-20230820182443491](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230820182443491.png)
