# 二叉搜索树概念

二叉搜索树（BST，Binary Search Tree）又称二叉排序树，二叉查找树

它或者是一棵空树，或者是具有以下性质的二叉树:

- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
- 它的左右子树也分别为二叉搜索树
- 键值是唯一的，所以二叉搜索树不能有相同的键值。

![image-20230821115334361](C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230821115334361.png)

# 二叉搜索树操作

[BST](https://github.com/DaysOfExperience/data_structure_and_STL/tree/main/data_structure)

二叉搜索树的查找（递归+非递归）

简单

二叉搜索树的插入（递归+非递归）

简单

二叉搜索树的删除（递归+非递归）

较为复杂，但也不难

> 先找，没找到，return false。找到了（此时也会记录其父节点），情况1：要删除的是根节点（无父节点），情况2：要删除的不是根节点（此时会记录其父节点）
>
> 情况一和情况二的处理是差不多的，只有一小部分不同。大体思路：分情况，情况1：要删除的结点的右子树为空，情况2：要删除的结点的左子树为空。情况3：要删除的结点的左右子树都不为空。情况4：要删除的结点的左右子树都为空（默认合并到了情况1或情况2）
>
> 针对情况1，2：
>
> 若要删除结点（cur）的左为空，则将cur的右赋值给parent的左或右（取决于cur是parent的左还是右）
>
> 若要删除结点（cur）的右为空，则将cur的左赋值给parent的左或右（取决于cur是parent的左还是右）
>
> 针对情况3：
>
> 去要删除的结点的右子树找最小结点min
>
> ```C++
> while(min->_left) {
>  minParent = min;
>  min = min->_left;
> }
> ```
>
> 然后交换要删除的结点的值和最小结点的值。之后的目标就变为了删除这个找出的最小结点，此时min的左子树一定为空。
> 然后再分情况，情况1：这个最小节点min是其父节点的右子结点，情况2：最小节点min是其父节点的左子节点。
>
> <img src="https://img-blog.csdnimg.cn/56fda86b55bd4596aa7d9fd6e68087d0.png" alt="img" style="zoom:67%;" />
>
> 若删除3（cur），则4是min，min是minParent的左。
>
> 若删除8（cur），则10是min，min是minparent的右。
>
> 此时要删除的结点的左子树为空，就可以按照情况2来处理，就很简单了。

# 二叉搜索树的应用

1. K模型：K模型即只有key作为关键码，二叉树结点结构中只需要存储Key即可，**关键码即为需要搜索到的值。** 如STL中的set
   比如：给一个单词word，判断该单词是否拼写正确，具体方式如下： 以词库中所有单词集合中的每个单词作为key，构建一棵二叉搜索树，在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。 
2. KV模型：每一个关键码key，都有与之对应的值Value，即<Key, Value>的键值对。**Value为需要搜索到的值。**如STL中的map
   该种方式在现实生活中非常常见，比如：英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英文单词与其对应的中文<word, chinese>就构成一种键值对； 
   再比如统计单词次数，统计成功后，给定单词就可快速找到其出现的次数，单词与其出现次数就是<word, count>就构成一种键值对。

# 二叉搜索树的作用

### 排序

**中序遍历**：先遍历左子树，再遍历根节点，再遍历右子树
而二叉搜索树的特性，左子树小于根节点，右子树大于根节点。
所以通过一趟中序遍历，即可获得排序的结果。

### 查找

**对于二叉搜索树，查找是其主要的功能**，STL中的map和set底层也是通过平衡二叉搜索树（红黑树）实现的。

二叉搜索树的查找十分简单，键值比根节点大则进入右子树，键值比根节点小则进入左子树，他的思路有点类似于二分查找，平均时间复杂度为O(log2N)

但是上述情况仅限于二叉搜索树为一个完全二叉树， 如果构建树时为有序数列，则二叉搜索树会退化为单支树，时间复杂度则会变为O(N）

# 二叉搜索树的性能分析

插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。

对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是**结点在二叉搜索树的深度**的函数，**即结点越深，则比较次数越多。**

但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230821182314122.png" style="zoom:67%;" />

最优情况下，二叉搜索树为完全二叉树(或者接近完全二叉树)，**时间复杂度**最好情况是O(logn)

最差情况下，二叉搜索树退化为单支树(或者类似单支)，最坏情况下时间复杂度O(n)

问题：如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，**不论按照什么次序插入关键码**，二叉搜索树的性能都能达到最优？那么我们后续章节学习的AVL树和红黑树就可以上场了。