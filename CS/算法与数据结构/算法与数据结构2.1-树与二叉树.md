# 树的概念

树是一种**非线性**的数据结构，它是由n（n>=0）个有限结点组成一个具有层次关系的集合。
把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200229205049221.png" alt="在这里插入图片描述" style="zoom:50%;" />

- 有一个特殊的结点，称为根节点，根节点没有前驱结点
- 除根节点外，其余结点被分成M个互不相交的集合T1、T2、、、、、Tm, 其中每一个集合Ti又是一棵结构与树类似的子树。每棵子树的根节点有且只有一个前驱，可以有0个或多个后驱结点（二叉树就是对于根节点来说，其余结点只能分为T1，T2）
- 子树是不相交的
- 除了根节点外，每个节点有且仅有一个父节点
- 一棵N个节点的树有N-1条边（除根节点）

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200229210152647.png" alt="在这里插入图片描述" style="zoom:50%;" />

- 节点的度：一个节点含有的子树的个数称为该节点的度，如节点D的度为2

- 叶子节点：度为零的结点为叶子节点，如上图所有#

- 父节点：如果一个节点含有子节点，则称这个节点为父节点，如C是E和#的父节点

- 子节点：一个结点含有的子树的根节点称为该节点的子节点，如A的子节点是B,C

- 兄弟节点：具有相同的父节点的结点互称为兄弟节点，如B,C是兄弟节点

- 树的度：树所包含的节点中，**拥有最大的分支的数目为该树的度**。上图是个二叉树度为2

- 树的深度（高度）：树中节点的最大层次

# 二叉树的概念和结构

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200229211643593.png)

一棵二叉树是结点的一个有限集合，该集合: 

1. 或者为空
2. 或者，由一个根节点加上两棵分别称为左子树和右子树的二叉树组成（树是递归定义的。）

二叉树是最常使用的树，特点是 ：

1. 每个节点最多有两棵子树，即二叉树不存在度大于2的节点
2. 二叉树的子树有左右之分，其子树的次序不能颠倒，因此二叉树是有序树

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230817003945980.png" alt="image-20230817003945980" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230817004204881.png" alt="image-20230817004204881" style="zoom:67%;" />

## 特殊的二叉树

**满二叉树：**
一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且节点总数为(2^k)-1，则就是满二叉树

完全二叉树：
满二叉树是一种特殊的完全二叉树，对于深度为k的，有n个节点的二叉树，当且仅当每一个节点都与深度为K的满二叉树中编号1~n的结点一一对应时称为完全二叉树

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200229212341942.png)

有一个很好的区分它们的方法，**满二叉树是除叶子节点外所有节点都存在左右子树的一棵树，而完全二叉树则是所有节点都是连续的，不存在有右子树而没有左子树的情况**

## 二叉树的性质

> 随便看看~

1. 一棵非空二叉树上的第i层最多有2^(i - 1)个节点（层数从1开始）
2. 深度为h的二叉树的最大节点数为2^n - 1个
3. 如果叶子节点的个数为n0，度为2的结点的个数为n2,则有 n0 = n2 + 1
4. 具有n个节点的完全二叉树的深度为h = log2(n) + 1
5. 如果一个结点的编号为i（从0开始），那么他的左孩子编号为2i +1，右孩子编号为2i +2，某节点的父节点为(i - 1) / 2

# 二叉树的存储结构

二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。

## 1. 顺序存储

**顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。**

**<u>而现实中使用中只有堆才会使用数组这样的物理结构来存储</u>**，关于堆我们后面的章节会专门讲解。

**二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230817004508817.png" alt="image-20230817004508817" style="zoom:80%;" />

## 2. 链式存储

二叉树的链式存储结构是指，**用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。**

通常的方法是：链表中每个结点由三个域组成，数据域和左右指针域，**左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。**

链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。

![image-20231204230555389](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231204230555389.png)

```C++
typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{
 struct BinTreeNode* _pLeft; // 指向当前节点左孩子
 struct BinTreeNode* _pRight; // 指向当前节点右孩子
 BTDataType _data; // 当前节点值域
}
// 三叉链
struct BinaryTreeNode
{
 struct BinTreeNode* _pParent; // 指向当前节点的双亲
 struct BinTreeNode* _pLeft; // 指向当前节点左孩子
 struct BinTreeNode* _pRight; // 指向当前节点右孩子
 BTDataType _data; // 当前节点值域
}；
```

# 二叉树的顺序结构及实现

见算法与数据结构2.2-堆与堆排序.md

# 二叉树的链式结构及实现

此处不学习如何创建出一个二叉树，只是手动拼接一个二叉树。然后快速上手学习二叉树的各项基本操作

## 二叉树的遍历

> 学习二叉树结构，最简单的方式就是遍历。

**二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树的所有节点，使得每个节点被访问且只访问一次。**

**<u>访问结点所做的操作依赖于具体的应用问题。</u> 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。**

---

而一般有四种遍历方法：前序、中序、后序、层序

1. 前序遍历(Preorder Traversal 亦称先序遍历)——**先访问根节点，再访问左子树，最后访问右子树。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200315232739319.png" alt="在这里插入图片描述" style="zoom:80%;" />

顺序：ABDECFG

有关非递归：递归法，在计算机中就是用栈来实现的（函数栈帧），而非递归就可以使用栈这个数据结构来实现。

```C++
// 二叉树前序遍历
void PreOrder(BTNode* root)
{
	if (root == nullptr)
	{
		cout << "# ";
		return;       // 空的话结束递归，输出#来表示这是一个空结点
	}
	cout << root->data << " ";   // 非空，对根节点的遍历操作：此处就是打印一下
	PreOrder(root->left);   // 遍历左子树
	PreOrder(root->right);  // 遍历右子树
}
// 二叉树前序非递归
vector<int> preorderTraversal(TreeNode* root) {
    std::stack<BTNode *> st;
    vector<int> vec;
    st.push(root);
    while(!st.empty()) {
        // 这里的每一次循环，都可以理解为对某一个树进行处理。
        
        // 取出了当前树的根节点
        BTNode *node = st.top();
        st.pop();
		if(node == nullptr) {
            continue;
        }
        else {
        	vec.push_back(node->data);   // 对前序的这个结点先处理
        	st.push(node->right);  // 先入右
        	st.push(node->left);   // 后入左，取出时就是先取左，即先左子树，再右子树。
        	// 若node是叶子节点，则左右子树为空，到时候取出来之后，直接continue不影响~
        }
	}
}
```

2. 中序遍历(Inorder Traversal)——**先访问左子树，再访问根节点，最后访问右子树。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/2020031600173535.png" alt="在这里插入图片描述" style="zoom:67%;" />

顺序：DBEAFCG

中序的非递归：这里我们访问的顺序和处理的顺序不同了，也就是先访问A但是先处理D

```C++
// 二叉树中序遍历
void InOrder(BTNode* root)
{
	if (root == nullptr)
	{
		cout << "# ";
		return;
	}

	InOrder(root->left);
	cout << root->data << " ";   // 非空，对根节点的中序遍历操作：此处就是打印一下
	InOrder(root->right);
}
// 二叉树中序非递归
vector<int> inorderTraversal(BTNode *root) {
    stack<BTNode *> st;
    vector<int> vec;
    BTNode *cur = root;
    while(cur || !st.empty()) {
        // cur是某一颗树（整棵树或者某子树）的根节点, 可能为空
        while(cur) {
            st.push(cur);
            cur = cur->left;
        }
        // 此时cur为空，代表着这个cur的父节点的左子树结束了
        BTNode *node = st.top();
        st.pop();
        // 此时的node的左子树结束了
        vec.push_back(node->data);  // 处理该结点，因为它的左子树结束了
        // 循环处理它的右子树，此时的右子树的情况是不知道的
        // 此时的处理，只需要把右子树的根节点赋值给cur然后循环即可，因为循环里的逻辑就是处理一个树的逻辑
        cur = node->right;
    }
    // 若有某一次 某节点的右子树为空, 则下次循环会从栈中取出元素, 此时该元素就是上次push的节点的父节点, 此时它的左处理完了, 处理他自己, 再处理它的右, 恩. 就是这样的
    return vec;
}
```

3. 后序遍历(Postorder Traversal)——**先访问左子树，再访问右子树，最后访问根节点。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/20200316002455108.png" alt="在这里插入图片描述" style="zoom:67%;" />

顺序：DEBFGCA

```C++
// 二叉树后序遍历
void PostOrder(BTNode* root)
{
	if (root == nullptr)
	{
		cout << "# ";
		return;
	}

	PostOrder(root->left);
	PostOrder(root->right);
	cout << root->data << " ";  // 非空，对根节点的后序遍历时的操作：此处就是打印一下
}
// 二叉树后序非递归
// 前序：中左右，后序：左右中 = reverse(中右左)
vector<int> postorderTraversal(BTNode *root) {
    stack<BTNode *> st;
    vector<int> vec;
    st.push(root);
    while(!st.empty()) {
        BTNode *node = st.top();
        st.pop();
        if(node == nullptr) continue;
        vec.push_back(node->data);
        st.push(node->left);
        st.push(node->right);
    }
    std::reverse(vec.begin(), vec.end());
    return vec;
}
```

> **其实前中后序遍历的区别，只是在于，对这个结点进行某些操作的时机**
>
> 是在遍历其左右子树之前，之中还是之后。
>
> 具体对节点进行的操作由具体要解决的问题决定。我的例子中是以打印为例。

递归的结束条件是，这个结点为空，为空则不进行下一步递归。

4. 层序遍历

**层序遍历顾名思义，就是一层一层往下遍历**

![image-20230817012042729](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230817012042729.png)

遍历顺序：ABCDEFGHI

下面用队列来层序遍历时，每次取的时候都是按照层序的方式取的，而每取出一个，都会将它的两个孩子入队列（这两个孩子是下一层的），主要利用的就是队列的先进先出！！！B先进，最后B就先出。B的孩子后进，B的孩子就后出。（因为B是由A入的，B的孩子是由B入的）

```C++
// 层序遍历 利用队列
void LevelOrder(BTNode* root) {
    queue<BTNode *> que;
    que.push(root);
    while(!que.empty()) {
        BTNode *node = que.front();
        que.pop();
        if(node != nullptr) {
            std::cout << node->data << " ";
            que.push(node->left);   // 可能为空~
            que.push(node->right);
        }
        else {
//            std::cout << "# ";
            continue;
        }
    }
}
```

## 二叉树的其他操作

```C++
// 二叉树节点个数
int BinaryTreeSize(BTNode* root);
// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root);
// 二叉树第k层节点个数
int BinaryTreeLevelKSize(BTNode* root, int k);
// 二叉树查找值为x的节点
BTNode* BinaryTreeFind(BTNode* root, BTDataType x);
// 通过前序遍历的数组"ABD##E#H##CF##G##"构建二叉树
BTNode* BinaryTreeCreate(BTDataType* a, int n, int* pi);
// 二叉树销毁
void BinaryTreeDestory(BTNode** root);
// 判断二叉树是否是完全二叉树
int BinaryTreeComplete(BTNode* root);
// 通过层序遍历的数组'...'构建二叉树
BTNode *BinaryTreeCreate(BTDataType *a, int n, int pos);
```

[链式二叉树](https://github.com/DaysOfExperience/data_structure_and_STL/blob/main/data_structure/BinaryTree.cpp)
